#include "dear_widgets.h"

//#include <clipper.hpp>

#include <algorithm>
#include <chrono>
#include <string>

#include <vector>
#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Warray-bounds"
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#endif
#ifdef _MSC_VER
#pragma warning( disable : 4101 )
#pragma warning( disable : 4244 )
#endif
namespace ImWidgets {
//////////////////////////////////////////////////////////////////////////
// Data
//////////////////////////////////////////////////////////////////////////
static float s_CIE_1931_2deg_min = 360.0f;
static float s_CIE_1931_2deg_max = 830.0f;
#define s_CIE_1931_2deg_samplesCount 471
static float s_CIE_1931_2deg_X[] = {
    0.000129900000f, 0.000145847000f, 0.000163802100f, 0.000184003700f, 0.000206690200f, 0.000232100000f,
    0.000260728000f, 0.000293075000f, 0.000329388000f, 0.000369914000f, 0.000414900000f, 0.000464158700f,
    0.000518986000f, 0.000581854000f, 0.000655234700f, 0.000741600000f, 0.000845029600f, 0.000964526800f,
    0.001094949000f, 0.001231154000f, 0.001368000000f, 0.001502050000f, 0.001642328000f, 0.001802382000f,
    0.001995757000f, 0.002236000000f, 0.002535385000f, 0.002892603000f, 0.003300829000f, 0.003753236000f,
    0.004243000000f, 0.004762389000f, 0.005330048000f, 0.005978712000f, 0.006741117000f, 0.007650000000f,
    0.008751373000f, 0.010028880000f, 0.011421700000f, 0.012869010000f, 0.014310000000f, 0.015704430000f,
    0.017147440000f, 0.018781220000f, 0.020748010000f, 0.023190000000f, 0.026207360000f, 0.029782480000f,
    0.033880920000f, 0.038468240000f, 0.043510000000f, 0.048995600000f, 0.055022600000f, 0.061718800000f,
    0.069212000000f, 0.077630000000f, 0.086958110000f, 0.097176720000f, 0.108406300000f, 0.120767200000f,
    0.134380000000f, 0.149358200000f, 0.165395700000f, 0.181983100000f, 0.198611000000f, 0.214770000000f,
    0.230186800000f, 0.244879700000f, 0.258777300000f, 0.271807900000f, 0.283900000000f, 0.294943800000f,
    0.304896500000f, 0.313787300000f, 0.321645400000f, 0.328500000000f, 0.334351300000f, 0.339210100000f,
    0.343121300000f, 0.346129600000f, 0.348280000000f, 0.349599900000f, 0.350147400000f, 0.350013000000f,
    0.349287000000f, 0.348060000000f, 0.346373300000f, 0.344262400000f, 0.341808800000f, 0.339094100000f,
    0.336200000000f, 0.333197700000f, 0.330041100000f, 0.326635700000f, 0.322886800000f, 0.318700000000f,
    0.314025100000f, 0.308884000000f, 0.303290400000f, 0.297257900000f, 0.290800000000f, 0.283970100000f,
    0.276721400000f, 0.268917800000f, 0.260422700000f, 0.251100000000f, 0.240847500000f, 0.229851200000f,
    0.218407200000f, 0.206811500000f, 0.195360000000f, 0.184213600000f, 0.173327300000f, 0.162688100000f,
    0.152283300000f, 0.142100000000f, 0.132178600000f, 0.122569600000f, 0.113275200000f, 0.104297900000f,
    0.095640000000f, 0.087299550000f, 0.079308040000f, 0.071717760000f, 0.064580990000f, 0.057950010000f,
    0.051862110000f, 0.046281520000f, 0.041150880000f, 0.036412830000f, 0.032010000000f, 0.027917200000f,
    0.024144400000f, 0.020687000000f, 0.017540400000f, 0.014700000000f, 0.012161790000f, 0.009919960000f,
    0.007967240000f, 0.006296346000f, 0.004900000000f, 0.003777173000f, 0.002945320000f, 0.002424880000f,
    0.002236293000f, 0.002400000000f, 0.002925520000f, 0.003836560000f, 0.005174840000f, 0.006982080000f,
    0.009300000000f, 0.012149490000f, 0.015535880000f, 0.019477520000f, 0.023992770000f, 0.029100000000f,
    0.034814850000f, 0.041120160000f, 0.047985040000f, 0.055378610000f, 0.063270000000f, 0.071635010000f,
    0.080462240000f, 0.089739960000f, 0.099456450000f, 0.109600000000f, 0.120167400000f, 0.131114500000f,
    0.142367900000f, 0.153854200000f, 0.165500000000f, 0.177257100000f, 0.189140000000f, 0.201169400000f,
    0.213365800000f, 0.225749900000f, 0.238320900000f, 0.251066800000f, 0.263992200000f, 0.277101700000f,
    0.290400000000f, 0.303891200000f, 0.317572600000f, 0.331438400000f, 0.345482800000f, 0.359700000000f,
    0.374083900000f, 0.388639600000f, 0.403378400000f, 0.418311500000f, 0.433449900000f, 0.448795300000f,
    0.464336000000f, 0.480064000000f, 0.495971300000f, 0.512050100000f, 0.528295900000f, 0.544691600000f,
    0.561209400000f, 0.577821500000f, 0.594500000000f, 0.611220900000f, 0.627975800000f, 0.644760200000f,
    0.661569700000f, 0.678400000000f, 0.695239200000f, 0.712058600000f, 0.728828400000f, 0.745518800000f,
    0.762100000000f, 0.778543200000f, 0.794825600000f, 0.810926400000f, 0.826824800000f, 0.842500000000f,
    0.857932500000f, 0.873081600000f, 0.887894400000f, 0.902318100000f, 0.916300000000f, 0.929799500000f,
    0.942798400000f, 0.955277600000f, 0.967217900000f, 0.978600000000f, 0.989385600000f, 0.999548800000f,
    1.009089200000f, 1.018006400000f, 1.026300000000f, 1.033982700000f, 1.040986000000f, 1.047188000000f,
    1.052466700000f, 1.056700000000f, 1.059794400000f, 1.061799200000f, 1.062806800000f, 1.062909600000f,
    1.062200000000f, 1.060735200000f, 1.058443600000f, 1.055224400000f, 1.050976800000f, 1.045600000000f,
    1.039036900000f, 1.031360800000f, 1.022666200000f, 1.013047700000f, 1.002600000000f, 0.991367500000f,
    0.979331400000f, 0.966491600000f, 0.952847900000f, 0.938400000000f, 0.923194000000f, 0.907244000000f,
    0.890502000000f, 0.872920000000f, 0.854449900000f, 0.835084000000f, 0.814946000000f, 0.794186000000f,
    0.772954000000f, 0.751400000000f, 0.729583600000f, 0.707588800000f, 0.685602200000f, 0.663810400000f,
    0.642400000000f, 0.621514900000f, 0.601113800000f, 0.581105200000f, 0.561397700000f, 0.541900000000f,
    0.522599500000f, 0.503546400000f, 0.484743600000f, 0.466193900000f, 0.447900000000f, 0.429861300000f,
    0.412098000000f, 0.394644000000f, 0.377533300000f, 0.360800000000f, 0.344456300000f, 0.328516800000f,
    0.313019200000f, 0.298001100000f, 0.283500000000f, 0.269544800000f, 0.256118400000f, 0.243189600000f,
    0.230727200000f, 0.218700000000f, 0.207097100000f, 0.195923200000f, 0.185170800000f, 0.174832300000f,
    0.164900000000f, 0.155366700000f, 0.146230000000f, 0.137490000000f, 0.129146700000f, 0.121200000000f,
    0.113639700000f, 0.106465000000f, 0.099690440000f, 0.093330610000f, 0.087400000000f, 0.081900960000f,
    0.076804280000f, 0.072077120000f, 0.067686640000f, 0.063600000000f, 0.059806850000f, 0.056282160000f,
    0.052971040000f, 0.049818610000f, 0.046770000000f, 0.043784050000f, 0.040875360000f, 0.038072640000f,
    0.035404610000f, 0.032900000000f, 0.030564190000f, 0.028380560000f, 0.026344840000f, 0.024452750000f,
    0.022700000000f, 0.021084290000f, 0.019599880000f, 0.018237320000f, 0.016987170000f, 0.015840000000f,
    0.014790640000f, 0.013831320000f, 0.012948680000f, 0.012129200000f, 0.011359160000f, 0.010629350000f,
    0.009938846000f, 0.009288422000f, 0.008678854000f, 0.008110916000f, 0.007582388000f, 0.007088746000f,
    0.006627313000f, 0.006195408000f, 0.005790346000f, 0.005409826000f, 0.005052583000f, 0.004717512000f,
    0.004403507000f, 0.004109457000f, 0.003833913000f, 0.003575748000f, 0.003334342000f, 0.003109075000f,
    0.002899327000f, 0.002704348000f, 0.002523020000f, 0.002354168000f, 0.002196616000f, 0.002049190000f,
    0.001910960000f, 0.001781438000f, 0.001660110000f, 0.001546459000f, 0.001439971000f, 0.001340042000f,
    0.001246275000f, 0.001158471000f, 0.001076430000f, 0.000999949300f, 0.000928735800f, 0.000862433200f,
    0.000800750300f, 0.000743396000f, 0.000690078600f, 0.000640515600f, 0.000594502100f, 0.000551864600f,
    0.000512429000f, 0.000476021300f, 0.000442453600f, 0.000411511700f, 0.000382981400f, 0.000356649100f,
    0.000332301100f, 0.000309758600f, 0.000288887100f, 0.000269539400f, 0.000251568200f, 0.000234826100f,
    0.000219171000f, 0.000204525800f, 0.000190840500f, 0.000178065400f, 0.000166150500f, 0.000155023600f,
    0.000144621900f, 0.000134909800f, 0.000125852000f, 0.000117413000f, 0.000109551500f, 0.000102224500f,
    0.000095394450f, 0.000089023900f, 0.000083075270f, 0.000077512690f, 0.000072313040f, 0.000067457780f,
    0.000062928440f, 0.000058706520f, 0.000054770280f, 0.000051099180f, 0.000047676540f, 0.000044485670f,
    0.000041509940f, 0.000038733240f, 0.000036142030f, 0.000033723520f, 0.000031464870f, 0.000029353260f,
    0.000027375730f, 0.000025524330f, 0.000023793760f, 0.000022178700f, 0.000020673830f, 0.000019272260f,
    0.000017966400f, 0.000016749910f, 0.000015616480f, 0.000014559770f, 0.000013573870f, 0.000012654360f,
    0.000011797230f, 0.000010998440f, 0.000010253980f, 0.000009559646f, 0.000008912044f, 0.000008308358f,
    0.000007745769f, 0.000007221456f, 0.000006732475f, 0.000006276423f, 0.000005851304f, 0.000005455118f,
    0.000005085868f, 0.000004741466f, 0.000004420236f, 0.000004120783f, 0.000003841716f, 0.000003581652f,
    0.000003339127f, 0.000003112949f, 0.000002902121f, 0.000002705645f, 0.000002522525f, 0.000002351726f,
    0.000002192415f, 0.000002043902f, 0.000001905497f, 0.000001776509f, 0.000001656215f, 0.000001544022f,
    0.000001439440f, 0.000001341977f, 0.000001251141f};
static float s_CIE_1931_2deg_Y[] = {
    0.000003917000f, 0.000004393581f, 0.000004929604f, 0.000005532136f, 0.000006208245f, 0.000006965000f,
    0.000007813219f, 0.000008767336f, 0.000009839844f, 0.000011043230f, 0.000012390000f, 0.000013886410f,
    0.000015557280f, 0.000017442960f, 0.000019583750f, 0.000022020000f, 0.000024839650f, 0.000028041260f,
    0.000031531040f, 0.000035215210f, 0.000039000000f, 0.000042826400f, 0.000046914600f, 0.000051589600f,
    0.000057176400f, 0.000064000000f, 0.000072344210f, 0.000082212240f, 0.000093508160f, 0.000106136100f,
    0.000120000000f, 0.000134984000f, 0.000151492000f, 0.000170208000f, 0.000191816000f, 0.000217000000f,
    0.000246906700f, 0.000281240000f, 0.000318520000f, 0.000357266700f, 0.000396000000f, 0.000433714700f,
    0.000473024000f, 0.000517876000f, 0.000572218700f, 0.000640000000f, 0.000724560000f, 0.000825500000f,
    0.000941160000f, 0.001069880000f, 0.001210000000f, 0.001362091000f, 0.001530752000f, 0.001720368000f,
    0.001935323000f, 0.002180000000f, 0.002454800000f, 0.002764000000f, 0.003117800000f, 0.003526400000f,
    0.004000000000f, 0.004546240000f, 0.005159320000f, 0.005829280000f, 0.006546160000f, 0.007300000000f,
    0.008086507000f, 0.008908720000f, 0.009767680000f, 0.010664430000f, 0.011600000000f, 0.012573170000f,
    0.013582720000f, 0.014629680000f, 0.015715090000f, 0.016840000000f, 0.018007360000f, 0.019214480000f,
    0.020453920000f, 0.021718240000f, 0.023000000000f, 0.024294610000f, 0.025610240000f, 0.026958570000f,
    0.028351250000f, 0.029800000000f, 0.031310830000f, 0.032883680000f, 0.034521120000f, 0.036225710000f,
    0.038000000000f, 0.039846670000f, 0.041768000000f, 0.043766000000f, 0.045842670000f, 0.048000000000f,
    0.050243680000f, 0.052573040000f, 0.054980560000f, 0.057458720000f, 0.060000000000f, 0.062601970000f,
    0.065277520000f, 0.068042080000f, 0.070911090000f, 0.073900000000f, 0.077016000000f, 0.080266400000f,
    0.083666800000f, 0.087232800000f, 0.090980000000f, 0.094917550000f, 0.099045840000f, 0.103367400000f,
    0.107884600000f, 0.112600000000f, 0.117532000000f, 0.122674400000f, 0.127992800000f, 0.133452800000f,
    0.139020000000f, 0.144676400000f, 0.150469300000f, 0.156461900000f, 0.162717700000f, 0.169300000000f,
    0.176243100000f, 0.183558100000f, 0.191273500000f, 0.199418000000f, 0.208020000000f, 0.217119900000f,
    0.226734500000f, 0.236857100000f, 0.247481200000f, 0.258600000000f, 0.270184900000f, 0.282293900000f,
    0.295050500000f, 0.308578000000f, 0.323000000000f, 0.338402100000f, 0.354685800000f, 0.371698600000f,
    0.389287500000f, 0.407300000000f, 0.425629900000f, 0.444309600000f, 0.463394400000f, 0.482939500000f,
    0.503000000000f, 0.523569300000f, 0.544512000000f, 0.565690000000f, 0.586965300000f, 0.608200000000f,
    0.629345600000f, 0.650306800000f, 0.670875200000f, 0.690842400000f, 0.710000000000f, 0.728185200000f,
    0.745463600000f, 0.761969400000f, 0.777836800000f, 0.793200000000f, 0.808110400000f, 0.822496200000f,
    0.836306800000f, 0.849491600000f, 0.862000000000f, 0.873810800000f, 0.884962400000f, 0.895493600000f,
    0.905443200000f, 0.914850100000f, 0.923734800000f, 0.932092400000f, 0.939922600000f, 0.947225200000f,
    0.954000000000f, 0.960256100000f, 0.966007400000f, 0.971260600000f, 0.976022500000f, 0.980300000000f,
    0.984092400000f, 0.987418200000f, 0.990312800000f, 0.992811600000f, 0.994950100000f, 0.996710800000f,
    0.998098300000f, 0.999112000000f, 0.999748200000f, 1.000000000000f, 0.999856700000f, 0.999304600000f,
    0.998325500000f, 0.996898700000f, 0.995000000000f, 0.992600500000f, 0.989742600000f, 0.986444400000f,
    0.982724100000f, 0.978600000000f, 0.974083700000f, 0.969171200000f, 0.963856800000f, 0.958134900000f,
    0.952000000000f, 0.945450400000f, 0.938499200000f, 0.931162800000f, 0.923457600000f, 0.915400000000f,
    0.907006400000f, 0.898277200000f, 0.889204800000f, 0.879781600000f, 0.870000000000f, 0.859861300000f,
    0.849392000000f, 0.838622000000f, 0.827581300000f, 0.816300000000f, 0.804794700000f, 0.793082000000f,
    0.781192000000f, 0.769154700000f, 0.757000000000f, 0.744754100000f, 0.732422400000f, 0.720003600000f,
    0.707496500000f, 0.694900000000f, 0.682219200000f, 0.669471600000f, 0.656674400000f, 0.643844800000f,
    0.631000000000f, 0.618155500000f, 0.605314400000f, 0.592475600000f, 0.579637900000f, 0.566800000000f,
    0.553961100000f, 0.541137200000f, 0.528352800000f, 0.515632300000f, 0.503000000000f, 0.490468800000f,
    0.478030400000f, 0.465677600000f, 0.453403200000f, 0.441200000000f, 0.429080000000f, 0.417036000000f,
    0.405032000000f, 0.393032000000f, 0.381000000000f, 0.368918400000f, 0.356827200000f, 0.344776800000f,
    0.332817600000f, 0.321000000000f, 0.309338100000f, 0.297850400000f, 0.286593600000f, 0.275624500000f,
    0.265000000000f, 0.254763200000f, 0.244889600000f, 0.235334400000f, 0.226052800000f, 0.217000000000f,
    0.208161600000f, 0.199548800000f, 0.191155200000f, 0.182974400000f, 0.175000000000f, 0.167223500000f,
    0.159646400000f, 0.152277600000f, 0.145125900000f, 0.138200000000f, 0.131500300000f, 0.125024800000f,
    0.118779200000f, 0.112769100000f, 0.107000000000f, 0.101476200000f, 0.096188640000f, 0.091122960000f,
    0.086264850000f, 0.081600000000f, 0.077120640000f, 0.072825520000f, 0.068710080000f, 0.064769760000f,
    0.061000000000f, 0.057396210000f, 0.053955040000f, 0.050673760000f, 0.047549650000f, 0.044580000000f,
    0.041758720000f, 0.039084960000f, 0.036563840000f, 0.034200480000f, 0.032000000000f, 0.029962610000f,
    0.028076640000f, 0.026329360000f, 0.024708050000f, 0.023200000000f, 0.021800770000f, 0.020501120000f,
    0.019281080000f, 0.018120690000f, 0.017000000000f, 0.015903790000f, 0.014837180000f, 0.013810680000f,
    0.012834780000f, 0.011920000000f, 0.011068310000f, 0.010273390000f, 0.009533311000f, 0.008846157000f,
    0.008210000000f, 0.007623781000f, 0.007085424000f, 0.006591476000f, 0.006138485000f, 0.005723000000f,
    0.005343059000f, 0.004995796000f, 0.004676404000f, 0.004380075000f, 0.004102000000f, 0.003838453000f,
    0.003589099000f, 0.003354219000f, 0.003134093000f, 0.002929000000f, 0.002738139000f, 0.002559876000f,
    0.002393244000f, 0.002237275000f, 0.002091000000f, 0.001953587000f, 0.001824580000f, 0.001703580000f,
    0.001590187000f, 0.001484000000f, 0.001384496000f, 0.001291268000f, 0.001204092000f, 0.001122744000f,
    0.001047000000f, 0.000976589600f, 0.000911108800f, 0.000850133200f, 0.000793238400f, 0.000740000000f,
    0.000690082700f, 0.000643310000f, 0.000599496000f, 0.000558454700f, 0.000520000000f, 0.000483913600f,
    0.000450052800f, 0.000418345200f, 0.000388718400f, 0.000361100000f, 0.000335383500f, 0.000311440400f,
    0.000289165600f, 0.000268453900f, 0.000249200000f, 0.000231301900f, 0.000214685600f, 0.000199288400f,
    0.000185047500f, 0.000171900000f, 0.000159778100f, 0.000148604400f, 0.000138301600f, 0.000128792500f,
    0.000120000000f, 0.000111859500f, 0.000104322400f, 0.000097335600f, 0.000090845870f, 0.000084800000f,
    0.000079146670f, 0.000073858000f, 0.000068916000f, 0.000064302670f, 0.000060000000f, 0.000055981870f,
    0.000052225600f, 0.000048718400f, 0.000045447470f, 0.000042400000f, 0.000039561040f, 0.000036915120f,
    0.000034448680f, 0.000032148160f, 0.000030000000f, 0.000027991250f, 0.000026113560f, 0.000024360240f,
    0.000022724610f, 0.000021200000f, 0.000019778550f, 0.000018452850f, 0.000017216870f, 0.000016064590f,
    0.000014990000f, 0.000013987280f, 0.000013051550f, 0.000012178180f, 0.000011362540f, 0.000010600000f,
    0.000009885877f, 0.000009217304f, 0.000008592362f, 0.000008009133f, 0.000007465700f, 0.000006959567f,
    0.000006487995f, 0.000006048699f, 0.000005639396f, 0.000005257800f, 0.000004901771f, 0.000004569720f,
    0.000004260194f, 0.000003971739f, 0.000003702900f, 0.000003452163f, 0.000003218302f, 0.000003000300f,
    0.000002797139f, 0.000002607800f, 0.000002431220f, 0.000002266531f, 0.000002113013f, 0.000001969943f,
    0.000001836600f, 0.000001712230f, 0.000001596228f, 0.000001488090f, 0.000001387314f, 0.000001293400f,
    0.000001205820f, 0.000001124143f, 0.000001048009f, 0.000000977058f, 0.000000910930f, 0.000000849251f,
    0.000000791721f, 0.000000738090f, 0.000000688110f, 0.000000641530f, 0.000000598090f, 0.000000557575f,
    0.000000519808f, 0.000000484612f, 0.000000451810f};
static float s_CIE_1931_2deg_Z[] = {
    0.000606100000f, 0.000680879200f, 0.000765145600f, 0.000860012400f, 0.000966592800f, 0.001086000000f,
    0.001220586000f, 0.001372729000f, 0.001543579000f, 0.001734286000f, 0.001946000000f, 0.002177777000f,
    0.002435809000f, 0.002731953000f, 0.003078064000f, 0.003486000000f, 0.003975227000f, 0.004540880000f,
    0.005158320000f, 0.005802907000f, 0.006450001000f, 0.007083216000f, 0.007745488000f, 0.008501152000f,
    0.009414544000f, 0.010549990000f, 0.011965800000f, 0.013655870000f, 0.015588050000f, 0.017730150000f,
    0.020050010000f, 0.022511360000f, 0.025202880000f, 0.028279720000f, 0.031897040000f, 0.036210000000f,
    0.041437710000f, 0.047503720000f, 0.054119880000f, 0.060998030000f, 0.067850010000f, 0.074486320000f,
    0.081361560000f, 0.089153640000f, 0.098540480000f, 0.110200000000f, 0.124613300000f, 0.141701700000f,
    0.161303500000f, 0.183256800000f, 0.207400000000f, 0.233692100000f, 0.262611400000f, 0.294774600000f,
    0.330798500000f, 0.371300000000f, 0.416209100000f, 0.465464200000f, 0.519694800000f, 0.579530300000f,
    0.645600000000f, 0.718483800000f, 0.796713300000f, 0.877845900000f, 0.959439000000f, 1.039050100000f,
    1.115367300000f, 1.188497100000f, 1.258123300000f, 1.323929600000f, 1.385600000000f, 1.442635200000f,
    1.494803500000f, 1.542190300000f, 1.584880700000f, 1.622960000000f, 1.656404800000f, 1.685295900000f,
    1.709874500000f, 1.730382100000f, 1.747060000000f, 1.760044600000f, 1.769623300000f, 1.776263700000f,
    1.780433400000f, 1.782600000000f, 1.782968200000f, 1.781699800000f, 1.779198200000f, 1.775867100000f,
    1.772110000000f, 1.768258900000f, 1.764039000000f, 1.758943800000f, 1.752466300000f, 1.744100000000f,
    1.733559500000f, 1.720858100000f, 1.705936900000f, 1.688737200000f, 1.669200000000f, 1.647528700000f,
    1.623412700000f, 1.596022300000f, 1.564528000000f, 1.528100000000f, 1.486111400000f, 1.439521500000f,
    1.389879900000f, 1.338736200000f, 1.287640000000f, 1.237422300000f, 1.187824300000f, 1.138761100000f,
    1.090148000000f, 1.041900000000f, 0.994197600000f, 0.947347300000f, 0.901453100000f, 0.856619300000f,
    0.812950100000f, 0.770517300000f, 0.729444800000f, 0.689913600000f, 0.652104900000f, 0.616200000000f,
    0.582328600000f, 0.550416200000f, 0.520337600000f, 0.491967300000f, 0.465180000000f, 0.439924600000f,
    0.416183600000f, 0.393882200000f, 0.372945900000f, 0.353300000000f, 0.334857800000f, 0.317552100000f,
    0.301337500000f, 0.286168600000f, 0.272000000000f, 0.258817100000f, 0.246483800000f, 0.234771800000f,
    0.223453300000f, 0.212300000000f, 0.201169200000f, 0.190119600000f, 0.179225400000f, 0.168560800000f,
    0.158200000000f, 0.148138300000f, 0.138375800000f, 0.128994200000f, 0.120075100000f, 0.111700000000f,
    0.103904800000f, 0.096667480000f, 0.089982720000f, 0.083845310000f, 0.078249990000f, 0.073208990000f,
    0.068678160000f, 0.064567840000f, 0.060788350000f, 0.057250010000f, 0.053904350000f, 0.050746640000f,
    0.047752760000f, 0.044898590000f, 0.042160000000f, 0.039507280000f, 0.036935640000f, 0.034458360000f,
    0.032088720000f, 0.029840000000f, 0.027711810000f, 0.025694440000f, 0.023787160000f, 0.021989250000f,
    0.020300000000f, 0.018718050000f, 0.017240360000f, 0.015863640000f, 0.014584610000f, 0.013400000000f,
    0.012307230000f, 0.011301880000f, 0.010377920000f, 0.009529306000f, 0.008749999000f, 0.008035200000f,
    0.007381600000f, 0.006785400000f, 0.006242800000f, 0.005749999000f, 0.005303600000f, 0.004899800000f,
    0.004534200000f, 0.004202400000f, 0.003900000000f, 0.003623200000f, 0.003370600000f, 0.003141400000f,
    0.002934800000f, 0.002749999000f, 0.002585200000f, 0.002438600000f, 0.002309400000f, 0.002196800000f,
    0.002100000000f, 0.002017733000f, 0.001948200000f, 0.001889800000f, 0.001840933000f, 0.001800000000f,
    0.001766267000f, 0.001737800000f, 0.001711200000f, 0.001683067000f, 0.001650001000f, 0.001610133000f,
    0.001564400000f, 0.001513600000f, 0.001458533000f, 0.001400000000f, 0.001336667000f, 0.001270000000f,
    0.001205000000f, 0.001146667000f, 0.001100000000f, 0.001068800000f, 0.001049400000f, 0.001035600000f,
    0.001021200000f, 0.001000000000f, 0.000968640000f, 0.000929920000f, 0.000886880000f, 0.000842560000f,
    0.000800000000f, 0.000760960000f, 0.000723680000f, 0.000685920000f, 0.000645440000f, 0.000600000000f,
    0.000547866700f, 0.000491600000f, 0.000435400000f, 0.000383466700f, 0.000340000000f, 0.000307253300f,
    0.000283160000f, 0.000265440000f, 0.000251813300f, 0.000240000000f, 0.000229546700f, 0.000220640000f,
    0.000211960000f, 0.000202186700f, 0.000190000000f, 0.000174213300f, 0.000155640000f, 0.000135960000f,
    0.000116853300f, 0.000100000000f, 0.000086133330f, 0.000074600000f, 0.000065000000f, 0.000056933330f,
    0.000049999990f, 0.000044160000f, 0.000039480000f, 0.000035720000f, 0.000032640000f, 0.000030000000f,
    0.000027653330f, 0.000025560000f, 0.000023640000f, 0.000021813330f, 0.000020000000f, 0.000018133330f,
    0.000016200000f, 0.000014200000f, 0.000012133330f, 0.000010000000f, 0.000007733333f, 0.000005400000f,
    0.000003200000f, 0.000001333333f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f};

static float s_CIE_1964_10deg_min = 360.0f;
static float s_CIE_1964_10deg_max = 830.0f;
#define s_CIE_1964_10deg_samplesCount 471
static float s_CIE_1964_10deg_X[] = {
    0.000000122200f, 0.000000185138f, 0.000000278830f, 0.000000417470f, 0.000000621330f, 0.000000919270f,
    0.000001351980f, 0.000001976540f, 0.000002872500f, 0.000004149500f, 0.000005958600f, 0.000008505600f,
    0.000012068600f, 0.000017022600f, 0.000023868000f, 0.000033266000f, 0.000046087000f, 0.000063472000f,
    0.000086892000f, 0.000118246000f, 0.000159952000f, 0.000215080000f, 0.000287490000f, 0.000381990000f,
    0.000504550000f, 0.000662440000f, 0.000864500000f, 0.001121500000f, 0.001446160000f, 0.001853590000f,
    0.002361600000f, 0.002990600000f, 0.003764500000f, 0.004710200000f, 0.005858100000f, 0.007242300000f,
    0.008899600000f, 0.010870900000f, 0.013198900000f, 0.015929200000f, 0.019109700000f, 0.022788000000f,
    0.027011000000f, 0.031829000000f, 0.037278000000f, 0.043400000000f, 0.050223000000f, 0.057764000000f,
    0.066038000000f, 0.075033000000f, 0.084736000000f, 0.095041000000f, 0.105836000000f, 0.117066000000f,
    0.128682000000f, 0.140638000000f, 0.152893000000f, 0.165416000000f, 0.178191000000f, 0.191214000000f,
    0.204492000000f, 0.217650000000f, 0.230267000000f, 0.242311000000f, 0.253793000000f, 0.264737000000f,
    0.275195000000f, 0.285301000000f, 0.295143000000f, 0.304869000000f, 0.314679000000f, 0.324355000000f,
    0.333570000000f, 0.342243000000f, 0.350312000000f, 0.357719000000f, 0.364482000000f, 0.370493000000f,
    0.375727000000f, 0.380158000000f, 0.383734000000f, 0.386327000000f, 0.387858000000f, 0.388396000000f,
    0.387978000000f, 0.386726000000f, 0.384696000000f, 0.382006000000f, 0.378709000000f, 0.374915000000f,
    0.370702000000f, 0.366089000000f, 0.361045000000f, 0.355518000000f, 0.349486000000f, 0.342957000000f,
    0.335893000000f, 0.328284000000f, 0.320150000000f, 0.311475000000f, 0.302273000000f, 0.292858000000f,
    0.283502000000f, 0.274044000000f, 0.264263000000f, 0.254085000000f, 0.243392000000f, 0.232187000000f,
    0.220488000000f, 0.208198000000f, 0.195618000000f, 0.183034000000f, 0.170222000000f, 0.157348000000f,
    0.144650000000f, 0.132349000000f, 0.120584000000f, 0.109456000000f, 0.099042000000f, 0.089388000000f,
    0.080507000000f, 0.072034000000f, 0.063710000000f, 0.055694000000f, 0.048117000000f, 0.041072000000f,
    0.034642000000f, 0.028896000000f, 0.023876000000f, 0.019628000000f, 0.016172000000f, 0.013300000000f,
    0.010759000000f, 0.008542000000f, 0.006661000000f, 0.005132000000f, 0.003982000000f, 0.003239000000f,
    0.002934000000f, 0.003114000000f, 0.003816000000f, 0.005095000000f, 0.006936000000f, 0.009299000000f,
    0.012147000000f, 0.015444000000f, 0.019156000000f, 0.023250000000f, 0.027690000000f, 0.032444000000f,
    0.037465000000f, 0.042956000000f, 0.049114000000f, 0.055920000000f, 0.063349000000f, 0.071358000000f,
    0.079901000000f, 0.088909000000f, 0.098293000000f, 0.107949000000f, 0.117749000000f, 0.127839000000f,
    0.138450000000f, 0.149516000000f, 0.161041000000f, 0.172953000000f, 0.185209000000f, 0.197755000000f,
    0.210538000000f, 0.223460000000f, 0.236491000000f, 0.249633000000f, 0.262972000000f, 0.276515000000f,
    0.290269000000f, 0.304213000000f, 0.318361000000f, 0.332705000000f, 0.347232000000f, 0.361926000000f,
    0.376772000000f, 0.391683000000f, 0.406594000000f, 0.421539000000f, 0.436517000000f, 0.451584000000f,
    0.466782000000f, 0.482147000000f, 0.497738000000f, 0.513606000000f, 0.529826000000f, 0.546440000000f,
    0.563426000000f, 0.580726000000f, 0.598290000000f, 0.616053000000f, 0.633948000000f, 0.651901000000f,
    0.669824000000f, 0.687632000000f, 0.705224000000f, 0.722773000000f, 0.740483000000f, 0.758273000000f,
    0.776083000000f, 0.793832000000f, 0.811436000000f, 0.828822000000f, 0.845879000000f, 0.862525000000f,
    0.878655000000f, 0.894208000000f, 0.909206000000f, 0.923672000000f, 0.937638000000f, 0.951162000000f,
    0.964283000000f, 0.977068000000f, 0.989590000000f, 1.001910000000f, 1.014160000000f, 1.026500000000f,
    1.038800000000f, 1.051000000000f, 1.062900000000f, 1.074300000000f, 1.085200000000f, 1.095200000000f,
    1.104200000000f, 1.112000000000f, 1.118520000000f, 1.123800000000f, 1.128000000000f, 1.131100000000f,
    1.133200000000f, 1.134300000000f, 1.134300000000f, 1.133300000000f, 1.131200000000f, 1.128100000000f,
    1.123990000000f, 1.118900000000f, 1.112900000000f, 1.105900000000f, 1.098000000000f, 1.089100000000f,
    1.079200000000f, 1.068400000000f, 1.056700000000f, 1.044000000000f, 1.030480000000f, 1.016000000000f,
    1.000800000000f, 0.984790000000f, 0.968080000000f, 0.950740000000f, 0.932800000000f, 0.914340000000f,
    0.895390000000f, 0.876030000000f, 0.856297000000f, 0.836350000000f, 0.816290000000f, 0.796050000000f,
    0.775610000000f, 0.754930000000f, 0.733990000000f, 0.712780000000f, 0.691290000000f, 0.669520000000f,
    0.647467000000f, 0.625110000000f, 0.602520000000f, 0.579890000000f, 0.557370000000f, 0.535110000000f,
    0.513240000000f, 0.491860000000f, 0.471080000000f, 0.450960000000f, 0.431567000000f, 0.412870000000f,
    0.394750000000f, 0.377210000000f, 0.360190000000f, 0.343690000000f, 0.327690000000f, 0.312170000000f,
    0.297110000000f, 0.282500000000f, 0.268329000000f, 0.254590000000f, 0.241300000000f, 0.228480000000f,
    0.216140000000f, 0.204300000000f, 0.192950000000f, 0.182110000000f, 0.171770000000f, 0.161920000000f,
    0.152568000000f, 0.143670000000f, 0.135200000000f, 0.127130000000f, 0.119480000000f, 0.112210000000f,
    0.105310000000f, 0.098786000000f, 0.092610000000f, 0.086773000000f, 0.081260600000f, 0.076048000000f,
    0.071114000000f, 0.066454000000f, 0.062062000000f, 0.057930000000f, 0.054050000000f, 0.050412000000f,
    0.047006000000f, 0.043823000000f, 0.040850800000f, 0.038072000000f, 0.035468000000f, 0.033031000000f,
    0.030753000000f, 0.028623000000f, 0.026635000000f, 0.024781000000f, 0.023052000000f, 0.021441000000f,
    0.019941300000f, 0.018544000000f, 0.017241000000f, 0.016027000000f, 0.014896000000f, 0.013842000000f,
    0.012862000000f, 0.011949000000f, 0.011100000000f, 0.010311000000f, 0.009576880000f, 0.008894000000f,
    0.008258100000f, 0.007666400000f, 0.007116300000f, 0.006605200000f, 0.006130600000f, 0.005690300000f,
    0.005281900000f, 0.004903300000f, 0.004552630000f, 0.004227500000f, 0.003925800000f, 0.003645700000f,
    0.003385900000f, 0.003144700000f, 0.002920800000f, 0.002713000000f, 0.002520200000f, 0.002341100000f,
    0.002174960000f, 0.002020600000f, 0.001877300000f, 0.001744100000f, 0.001620500000f, 0.001505700000f,
    0.001399200000f, 0.001300400000f, 0.001208700000f, 0.001123600000f, 0.001044760000f, 0.000971560000f,
    0.000903600000f, 0.000840480000f, 0.000781870000f, 0.000727450000f, 0.000676900000f, 0.000629960000f,
    0.000586370000f, 0.000545870000f, 0.000508258000f, 0.000473300000f, 0.000440800000f, 0.000410580000f,
    0.000382490000f, 0.000356380000f, 0.000332110000f, 0.000309550000f, 0.000288580000f, 0.000269090000f,
    0.000250969000f, 0.000234130000f, 0.000218470000f, 0.000203910000f, 0.000190350000f, 0.000177730000f,
    0.000165970000f, 0.000155020000f, 0.000144800000f, 0.000135280000f, 0.000126390000f, 0.000118100000f,
    0.000110370000f, 0.000103150000f, 0.000096427000f, 0.000090151000f, 0.000084294000f, 0.000078830000f,
    0.000073729000f, 0.000068969000f, 0.000064525800f, 0.000060376000f, 0.000056500000f, 0.000052880000f,
    0.000049498000f, 0.000046339000f, 0.000043389000f, 0.000040634000f, 0.000038060000f, 0.000035657000f,
    0.000033411700f, 0.000031315000f, 0.000029355000f, 0.000027524000f, 0.000025811000f, 0.000024209000f,
    0.000022711000f, 0.000021308000f, 0.000019994000f, 0.000018764000f, 0.000017611500f, 0.000016532000f,
    0.000015521000f, 0.000014574000f, 0.000013686000f, 0.000012855000f, 0.000012075000f, 0.000011345000f,
    0.000010659000f, 0.000010017000f, 0.000009413630f, 0.000008847900f, 0.000008317100f, 0.000007819000f,
    0.000007351600f, 0.000006913000f, 0.000006501500f, 0.000006115300f, 0.000005752900f, 0.000005412700f,
    0.000005093470f, 0.000004793800f, 0.000004512500f, 0.000004248300f, 0.000004000200f, 0.000003767100f,
    0.000003548000f, 0.000003342100f, 0.000003148500f, 0.000002966500f, 0.000002795310f, 0.000002634500f,
    0.000002483400f, 0.000002341400f, 0.000002207800f, 0.000002082000f, 0.000001963600f, 0.000001851900f,
    0.000001746500f, 0.000001647100f, 0.000001553140f};
static float s_CIE_1964_10deg_Y[] = {
    0.000000013398f, 0.000000020294f, 0.000000030560f, 0.000000045740f, 0.000000068050f, 0.000000100650f,
    0.000000147980f, 0.000000216270f, 0.000000314200f, 0.000000453700f, 0.000000651100f, 0.000000928800f,
    0.000001317500f, 0.000001857200f, 0.000002602000f, 0.000003625000f, 0.000005019000f, 0.000006907000f,
    0.000009449000f, 0.000012848000f, 0.000017364000f, 0.000023327000f, 0.000031150000f, 0.000041350000f,
    0.000054560000f, 0.000071560000f, 0.000093300000f, 0.000120870000f, 0.000155640000f, 0.000199200000f,
    0.000253400000f, 0.000320200000f, 0.000402400000f, 0.000502300000f, 0.000623200000f, 0.000768500000f,
    0.000941700000f, 0.001147800000f, 0.001390300000f, 0.001674000000f, 0.002004400000f, 0.002386000000f,
    0.002822000000f, 0.003319000000f, 0.003880000000f, 0.004509000000f, 0.005209000000f, 0.005985000000f,
    0.006833000000f, 0.007757000000f, 0.008756000000f, 0.009816000000f, 0.010918000000f, 0.012058000000f,
    0.013237000000f, 0.014456000000f, 0.015717000000f, 0.017025000000f, 0.018399000000f, 0.019848000000f,
    0.021391000000f, 0.022992000000f, 0.024598000000f, 0.026213000000f, 0.027841000000f, 0.029497000000f,
    0.031195000000f, 0.032927000000f, 0.034738000000f, 0.036654000000f, 0.038676000000f, 0.040792000000f,
    0.042946000000f, 0.045114000000f, 0.047333000000f, 0.049602000000f, 0.051934000000f, 0.054337000000f,
    0.056822000000f, 0.059399000000f, 0.062077000000f, 0.064737000000f, 0.067285000000f, 0.069764000000f,
    0.072218000000f, 0.074704000000f, 0.077272000000f, 0.079979000000f, 0.082874000000f, 0.086000000000f,
    0.089456000000f, 0.092947000000f, 0.096275000000f, 0.099535000000f, 0.102829000000f, 0.106256000000f,
    0.109901000000f, 0.113835000000f, 0.118167000000f, 0.122932000000f, 0.128201000000f, 0.133457000000f,
    0.138323000000f, 0.143042000000f, 0.147787000000f, 0.152761000000f, 0.158102000000f, 0.163941000000f,
    0.170362000000f, 0.177425000000f, 0.185190000000f, 0.193025000000f, 0.200313000000f, 0.207156000000f,
    0.213644000000f, 0.219940000000f, 0.226170000000f, 0.232467000000f, 0.239025000000f, 0.245997000000f,
    0.253589000000f, 0.261876000000f, 0.270643000000f, 0.279645000000f, 0.288694000000f, 0.297665000000f,
    0.306469000000f, 0.315035000000f, 0.323335000000f, 0.331366000000f, 0.339133000000f, 0.347860000000f,
    0.358326000000f, 0.370001000000f, 0.382464000000f, 0.395379000000f, 0.408482000000f, 0.421588000000f,
    0.434619000000f, 0.447601000000f, 0.460777000000f, 0.474340000000f, 0.488200000000f, 0.502340000000f,
    0.516740000000f, 0.531360000000f, 0.546190000000f, 0.561180000000f, 0.576290000000f, 0.591500000000f,
    0.606741000000f, 0.622150000000f, 0.637830000000f, 0.653710000000f, 0.669680000000f, 0.685660000000f,
    0.701550000000f, 0.717230000000f, 0.732570000000f, 0.747460000000f, 0.761757000000f, 0.775340000000f,
    0.788220000000f, 0.800460000000f, 0.812140000000f, 0.823330000000f, 0.834120000000f, 0.844600000000f,
    0.854870000000f, 0.865040000000f, 0.875211000000f, 0.885370000000f, 0.895370000000f, 0.905150000000f,
    0.914650000000f, 0.923810000000f, 0.932550000000f, 0.940810000000f, 0.948520000000f, 0.955600000000f,
    0.961988000000f, 0.967540000000f, 0.972230000000f, 0.976170000000f, 0.979460000000f, 0.982200000000f,
    0.984520000000f, 0.986520000000f, 0.988320000000f, 0.990020000000f, 0.991761000000f, 0.993530000000f,
    0.995230000000f, 0.996770000000f, 0.998090000000f, 0.999110000000f, 0.999770000000f, 1.000000000000f,
    0.999710000000f, 0.998850000000f, 0.997340000000f, 0.995260000000f, 0.992740000000f, 0.989750000000f,
    0.986300000000f, 0.982380000000f, 0.977980000000f, 0.973110000000f, 0.967740000000f, 0.961890000000f,
    0.955552000000f, 0.948601000000f, 0.940981000000f, 0.932798000000f, 0.924158000000f, 0.915175000000f,
    0.905954000000f, 0.896608000000f, 0.887249000000f, 0.877986000000f, 0.868934000000f, 0.860164000000f,
    0.851519000000f, 0.842963000000f, 0.834393000000f, 0.825623000000f, 0.816764000000f, 0.807544000000f,
    0.797947000000f, 0.787893000000f, 0.777405000000f, 0.766490000000f, 0.755309000000f, 0.743845000000f,
    0.732190000000f, 0.720353000000f, 0.708281000000f, 0.696055000000f, 0.683621000000f, 0.671048000000f,
    0.658341000000f, 0.645545000000f, 0.632718000000f, 0.619815000000f, 0.606887000000f, 0.593878000000f,
    0.580781000000f, 0.567653000000f, 0.554490000000f, 0.541228000000f, 0.527963000000f, 0.514634000000f,
    0.501363000000f, 0.488124000000f, 0.474935000000f, 0.461834000000f, 0.448823000000f, 0.435917000000f,
    0.423153000000f, 0.410526000000f, 0.398057000000f, 0.385835000000f, 0.373951000000f, 0.362311000000f,
    0.350863000000f, 0.339554000000f, 0.328309000000f, 0.317118000000f, 0.305936000000f, 0.294737000000f,
    0.283493000000f, 0.272222000000f, 0.260990000000f, 0.249877000000f, 0.238946000000f, 0.228254000000f,
    0.217853000000f, 0.207780000000f, 0.198072000000f, 0.188748000000f, 0.179828000000f, 0.171285000000f,
    0.163059000000f, 0.155151000000f, 0.147535000000f, 0.140211000000f, 0.133170000000f, 0.126400000000f,
    0.119892000000f, 0.113640000000f, 0.107633000000f, 0.101870000000f, 0.096347000000f, 0.091063000000f,
    0.086010000000f, 0.081187000000f, 0.076583000000f, 0.072198000000f, 0.068024000000f, 0.064052000000f,
    0.060281000000f, 0.056697000000f, 0.053292000000f, 0.050059000000f, 0.046998000000f, 0.044096000000f,
    0.041345000000f, 0.038750700000f, 0.036297800000f, 0.033983200000f, 0.031800400000f, 0.029739500000f,
    0.027791800000f, 0.025955100000f, 0.024226300000f, 0.022601700000f, 0.021077900000f, 0.019650500000f,
    0.018315300000f, 0.017068600000f, 0.015905100000f, 0.014818300000f, 0.013800800000f, 0.012849500000f,
    0.011960700000f, 0.011130300000f, 0.010355500000f, 0.009633200000f, 0.008959900000f, 0.008332400000f,
    0.007748800000f, 0.007204600000f, 0.006697500000f, 0.006225100000f, 0.005785000000f, 0.005375100000f,
    0.004994100000f, 0.004639200000f, 0.004309300000f, 0.004002800000f, 0.003717740000f, 0.003452620000f,
    0.003205830000f, 0.002976230000f, 0.002762810000f, 0.002564560000f, 0.002380480000f, 0.002209710000f,
    0.002051320000f, 0.001904490000f, 0.001768470000f, 0.001642360000f, 0.001525350000f, 0.001416720000f,
    0.001315950000f, 0.001222390000f, 0.001135550000f, 0.001054940000f, 0.000980140000f, 0.000910660000f,
    0.000846190000f, 0.000786290000f, 0.000730680000f, 0.000678990000f, 0.000631010000f, 0.000586440000f,
    0.000545110000f, 0.000506720000f, 0.000471110000f, 0.000438050000f, 0.000407410000f, 0.000378962000f,
    0.000352543000f, 0.000328001000f, 0.000305208000f, 0.000284041000f, 0.000264375000f, 0.000246109000f,
    0.000229143000f, 0.000213376000f, 0.000198730000f, 0.000185115000f, 0.000172454000f, 0.000160678000f,
    0.000149730000f, 0.000139550000f, 0.000130086000f, 0.000121290000f, 0.000113106000f, 0.000105501000f,
    0.000098428000f, 0.000091853000f, 0.000085738000f, 0.000080048000f, 0.000074751000f, 0.000069819000f,
    0.000065222000f, 0.000060939000f, 0.000056942000f, 0.000053217000f, 0.000049737000f, 0.000046491000f,
    0.000043464000f, 0.000040635000f, 0.000038000000f, 0.000035540500f, 0.000033244800f, 0.000031100600f,
    0.000029099000f, 0.000027230700f, 0.000025486000f, 0.000023856100f, 0.000022333200f, 0.000020910400f,
    0.000019580800f, 0.000018338400f, 0.000017177700f, 0.000016093400f, 0.000015080000f, 0.000014133600f,
    0.000013249000f, 0.000012422600f, 0.000011649900f, 0.000010927700f, 0.000010251900f, 0.000009619600f,
    0.000009028100f, 0.000008474000f, 0.000007954800f, 0.000007468600f, 0.000007012800f, 0.000006585800f,
    0.000006185700f, 0.000005810700f, 0.000005459000f, 0.000005129800f, 0.000004820600f, 0.000004531200f,
    0.000004259100f, 0.000004004200f, 0.000003764730f, 0.000003539950f, 0.000003329140f, 0.000003131150f,
    0.000002945290f, 0.000002770810f, 0.000002607050f, 0.000002453290f, 0.000002308940f, 0.000002173380f,
    0.000002046130f, 0.000001926620f, 0.000001814400f, 0.000001708950f, 0.000001609880f, 0.000001516770f,
    0.000001429210f, 0.000001346860f, 0.000001269450f, 0.000001196620f, 0.000001128090f, 0.000001063680f,
    0.000001003130f, 0.000000946220f, 0.000000892630f, 0.000000842160f, 0.000000794640f, 0.000000749780f,
    0.000000707440f, 0.000000667480f, 0.000000629700f};
static float s_CIE_1964_10deg_Z[] = {
    0.000000535027f, 0.000000810720f, 0.000001221200f, 0.000001828700f, 0.000002722200f, 0.000004028300f,
    0.000005925700f, 0.000008665100f, 0.000012596000f, 0.000018201000f, 0.000026143700f, 0.000037330000f,
    0.000052987000f, 0.000074764000f, 0.000104870000f, 0.000146220000f, 0.000202660000f, 0.000279230000f,
    0.000382450000f, 0.000520720000f, 0.000704776000f, 0.000948230000f, 0.001268200000f, 0.001686100000f,
    0.002228500000f, 0.002927800000f, 0.003823700000f, 0.004964200000f, 0.006406700000f, 0.008219300000f,
    0.010482200000f, 0.013289000000f, 0.016747000000f, 0.020980000000f, 0.026127000000f, 0.032344000000f,
    0.039802000000f, 0.048691000000f, 0.059210000000f, 0.071576000000f, 0.086010900000f, 0.102740000000f,
    0.122000000000f, 0.144020000000f, 0.168990000000f, 0.197120000000f, 0.228570000000f, 0.263470000000f,
    0.301900000000f, 0.343870000000f, 0.389366000000f, 0.437970000000f, 0.489220000000f, 0.542900000000f,
    0.598810000000f, 0.656760000000f, 0.716580000000f, 0.778120000000f, 0.841310000000f, 0.906110000000f,
    0.972542000000f, 1.038900000000f, 1.103100000000f, 1.165100000000f, 1.224900000000f, 1.282500000000f,
    1.338200000000f, 1.392600000000f, 1.446100000000f, 1.499400000000f, 1.553480000000f, 1.607200000000f,
    1.658900000000f, 1.708200000000f, 1.754800000000f, 1.798500000000f, 1.839200000000f, 1.876600000000f,
    1.910500000000f, 1.940800000000f, 1.967280000000f, 1.989100000000f, 2.005700000000f, 2.017400000000f,
    2.024400000000f, 2.027300000000f, 2.026400000000f, 2.022300000000f, 2.015300000000f, 2.006000000000f,
    1.994800000000f, 1.981400000000f, 1.965300000000f, 1.946400000000f, 1.924800000000f, 1.900700000000f,
    1.874100000000f, 1.845100000000f, 1.813900000000f, 1.780600000000f, 1.745370000000f, 1.709100000000f,
    1.672300000000f, 1.634700000000f, 1.595600000000f, 1.554900000000f, 1.512200000000f, 1.467300000000f,
    1.419900000000f, 1.370000000000f, 1.317560000000f, 1.262400000000f, 1.205000000000f, 1.146600000000f,
    1.088000000000f, 1.030200000000f, 0.973830000000f, 0.919430000000f, 0.867460000000f, 0.818280000000f,
    0.772125000000f, 0.728290000000f, 0.686040000000f, 0.645530000000f, 0.606850000000f, 0.570060000000f,
    0.535220000000f, 0.502340000000f, 0.471400000000f, 0.442390000000f, 0.415254000000f, 0.390024000000f,
    0.366399000000f, 0.344015000000f, 0.322689000000f, 0.302356000000f, 0.283036000000f, 0.264816000000f,
    0.247848000000f, 0.232318000000f, 0.218502000000f, 0.205851000000f, 0.193596000000f, 0.181736000000f,
    0.170281000000f, 0.159249000000f, 0.148673000000f, 0.138609000000f, 0.129096000000f, 0.120215000000f,
    0.112044000000f, 0.104710000000f, 0.098196000000f, 0.092361000000f, 0.087088000000f, 0.082248000000f,
    0.077744000000f, 0.073456000000f, 0.069268000000f, 0.065060000000f, 0.060709000000f, 0.056457000000f,
    0.052609000000f, 0.049122000000f, 0.045954000000f, 0.043050000000f, 0.040368000000f, 0.037839000000f,
    0.035384000000f, 0.032949000000f, 0.030451000000f, 0.028029000000f, 0.025862000000f, 0.023920000000f,
    0.022174000000f, 0.020584000000f, 0.019127000000f, 0.017740000000f, 0.016403000000f, 0.015064000000f,
    0.013676000000f, 0.012308000000f, 0.011056000000f, 0.009915000000f, 0.008872000000f, 0.007918000000f,
    0.007030000000f, 0.006223000000f, 0.005453000000f, 0.004714000000f, 0.003988000000f, 0.003289000000f,
    0.002646000000f, 0.002063000000f, 0.001533000000f, 0.001091000000f, 0.000711000000f, 0.000407000000f,
    0.000184000000f, 0.000047000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f, 0.000000000000f,
    0.000000000000f, 0.000000000000f, 0.000000000000f};

static float s_Illuminance_D65_min = 300.0f;
static float s_Illuminance_D65_max = 830.0f;
#define s_Illuminance_D65_samplesCount 531
static float s_Illuminance_D65[] = {
    0.034100f,   0.360140f,   0.686180f,   1.012220f,   1.338260f,   1.664300f,   1.990340f,   2.316380f,   2.642420f,
    2.968460f,   3.294500f,   4.988650f,   6.682800f,   8.376950f,   10.071100f,  11.765200f,  13.459400f,  15.153500f,
    16.847700f,  18.541800f,  20.236000f,  21.917700f,  23.599500f,  25.281200f,  26.963000f,  28.644700f,  30.326500f,
    32.008200f,  33.690000f,  35.371700f,  37.053500f,  37.343000f,  37.632600f,  37.922100f,  38.211600f,  38.501100f,
    38.790700f,  39.080200f,  39.369700f,  39.659300f,  39.948800f,  40.445100f,  40.941400f,  41.437700f,  41.934000f,
    42.430200f,  42.926500f,  43.422800f,  43.919100f,  44.415400f,  44.911700f,  45.084400f,  45.257000f,  45.429700f,
    45.602300f,  45.775000f,  45.947700f,  46.120300f,  46.293000f,  46.465600f,  46.638300f,  47.183400f,  47.728500f,
    48.273500f,  48.818600f,  49.363700f,  49.908800f,  50.453900f,  50.998900f,  51.544000f,  52.089100f,  51.877700f,
    51.666400f,  51.455000f,  51.243700f,  51.032300f,  50.820900f,  50.609600f,  50.398200f,  50.186900f,  49.975500f,
    50.442800f,  50.910000f,  51.377300f,  51.844600f,  52.311800f,  52.779100f,  53.246400f,  53.713700f,  54.180900f,
    54.648200f,  57.458900f,  60.269500f,  63.080200f,  65.890900f,  68.701500f,  71.512200f,  74.322900f,  77.133600f,
    79.944200f,  82.754900f,  83.628000f,  84.501100f,  85.374200f,  86.247300f,  87.120400f,  87.993600f,  88.866700f,
    89.739800f,  90.612900f,  91.486000f,  91.680600f,  91.875200f,  92.069700f,  92.264300f,  92.458900f,  92.653500f,
    92.848100f,  93.042600f,  93.237200f,  93.431800f,  92.756800f,  92.081900f,  91.406900f,  90.732000f,  90.057000f,
    89.382100f,  88.707100f,  88.032200f,  87.357200f,  86.682300f,  88.500600f,  90.318800f,  92.137100f,  93.955400f,
    95.773600f,  97.591900f,  99.410200f,  101.228000f, 103.047000f, 104.865000f, 106.079000f, 107.294000f, 108.508000f,
    109.722000f, 110.936000f, 112.151000f, 113.365000f, 114.579000f, 115.794000f, 117.008000f, 117.088000f, 117.169000f,
    117.249000f, 117.330000f, 117.410000f, 117.490000f, 117.571000f, 117.651000f, 117.732000f, 117.812000f, 117.517000f,
    117.222000f, 116.927000f, 116.632000f, 116.336000f, 116.041000f, 115.746000f, 115.451000f, 115.156000f, 114.861000f,
    114.967000f, 115.073000f, 115.180000f, 115.286000f, 115.392000f, 115.498000f, 115.604000f, 115.711000f, 115.817000f,
    115.923000f, 115.212000f, 114.501000f, 113.789000f, 113.078000f, 112.367000f, 111.656000f, 110.945000f, 110.233000f,
    109.522000f, 108.811000f, 108.865000f, 108.920000f, 108.974000f, 109.028000f, 109.082000f, 109.137000f, 109.191000f,
    109.245000f, 109.300000f, 109.354000f, 109.199000f, 109.044000f, 108.888000f, 108.733000f, 108.578000f, 108.423000f,
    108.268000f, 108.112000f, 107.957000f, 107.802000f, 107.501000f, 107.200000f, 106.898000f, 106.597000f, 106.296000f,
    105.995000f, 105.694000f, 105.392000f, 105.091000f, 104.790000f, 105.080000f, 105.370000f, 105.660000f, 105.950000f,
    106.239000f, 106.529000f, 106.819000f, 107.109000f, 107.399000f, 107.689000f, 107.361000f, 107.032000f, 106.704000f,
    106.375000f, 106.047000f, 105.719000f, 105.390000f, 105.062000f, 104.733000f, 104.405000f, 104.369000f, 104.333000f,
    104.297000f, 104.261000f, 104.225000f, 104.190000f, 104.154000f, 104.118000f, 104.082000f, 104.046000f, 103.641000f,
    103.237000f, 102.832000f, 102.428000f, 102.023000f, 101.618000f, 101.214000f, 100.809000f, 100.405000f, 100.000000f,
    99.633400f,  99.266800f,  98.900300f,  98.533700f,  98.167100f,  97.800500f,  97.433900f,  97.067400f,  96.700800f,
    96.334200f,  96.279600f,  96.225000f,  96.170300f,  96.115700f,  96.061100f,  96.006500f,  95.951900f,  95.897200f,
    95.842600f,  95.788000f,  95.077800f,  94.367500f,  93.657300f,  92.947000f,  92.236800f,  91.526600f,  90.816300f,
    90.106100f,  89.395800f,  88.685600f,  88.817700f,  88.949700f,  89.081800f,  89.213800f,  89.345900f,  89.478000f,
    89.610000f,  89.742100f,  89.874100f,  90.006200f,  89.965500f,  89.924800f,  89.884100f,  89.843400f,  89.802600f,
    89.761900f,  89.721200f,  89.680500f,  89.639800f,  89.599100f,  89.409100f,  89.219000f,  89.029000f,  88.838900f,
    88.648900f,  88.458900f,  88.268800f,  88.078800f,  87.888700f,  87.698700f,  87.257700f,  86.816700f,  86.375700f,
    85.934700f,  85.493600f,  85.052600f,  84.611600f,  84.170600f,  83.729600f,  83.288600f,  83.329700f,  83.370700f,
    83.411800f,  83.452800f,  83.493900f,  83.535000f,  83.576000f,  83.617100f,  83.658100f,  83.699200f,  83.332000f,
    82.964700f,  82.597500f,  82.230200f,  81.863000f,  81.495800f,  81.128500f,  80.761300f,  80.394000f,  80.026800f,
    80.045600f,  80.064400f,  80.083100f,  80.101900f,  80.120700f,  80.139500f,  80.158300f,  80.177000f,  80.195800f,
    80.214600f,  80.420900f,  80.627200f,  80.833600f,  81.039900f,  81.246200f,  81.452500f,  81.658800f,  81.865200f,
    82.071500f,  82.277800f,  81.878400f,  81.479100f,  81.079700f,  80.680400f,  80.281000f,  79.881600f,  79.482300f,
    79.082900f,  78.683600f,  78.284200f,  77.427900f,  76.571600f,  75.715300f,  74.859000f,  74.002700f,  73.146500f,
    72.290200f,  71.433900f,  70.577600f,  69.721300f,  69.910100f,  70.098900f,  70.287600f,  70.476400f,  70.665200f,
    70.854000f,  71.042800f,  71.231500f,  71.420300f,  71.609100f,  71.883100f,  72.157100f,  72.431100f,  72.705100f,
    72.979000f,  73.253000f,  73.527000f,  73.801000f,  74.075000f,  74.349000f,  73.074500f,  71.800000f,  70.525500f,
    69.251000f,  67.976500f,  66.702000f,  65.427500f,  64.153000f,  62.878500f,  61.604000f,  62.432200f,  63.260300f,
    64.088500f,  64.916600f,  65.744800f,  66.573000f,  67.401100f,  68.229300f,  69.057400f,  69.885600f,  70.405700f,
    70.925900f,  71.446000f,  71.966200f,  72.486300f,  73.006400f,  73.526600f,  74.046700f,  74.566900f,  75.087000f,
    73.937600f,  72.788100f,  71.638700f,  70.489300f,  69.339800f,  68.190400f,  67.041000f,  65.891600f,  64.742100f,
    63.592700f,  61.875200f,  60.157800f,  58.440300f,  56.722900f,  55.005400f,  53.288000f,  51.570500f,  49.853100f,
    48.135600f,  46.418200f,  48.456900f,  50.495600f,  52.534400f,  54.573100f,  56.611800f,  58.650500f,  60.689200f,
    62.728000f,  64.766700f,  66.805400f,  66.463100f,  66.120900f,  65.778600f,  65.436400f,  65.094100f,  64.751800f,
    64.409600f,  64.067300f,  63.725100f,  63.382800f,  63.474900f,  63.567000f,  63.659200f,  63.751300f,  63.843400f,
    63.935500f,  64.027600f,  64.119800f,  64.211900f,  64.304000f,  63.818800f,  63.333600f,  62.848400f,  62.363200f,
    61.877900f,  61.392700f,  60.907500f,  60.422300f,  59.937100f,  59.451900f,  58.702600f,  57.953300f,  57.204000f,
    56.454700f,  55.705400f,  54.956200f,  54.206900f,  53.457600f,  52.708300f,  51.959000f,  52.507200f,  53.055300f,
    53.603500f,  54.151600f,  54.699800f,  55.248000f,  55.796100f,  56.344300f,  56.892400f,  57.440600f,  57.727800f,
    58.015000f,  58.302200f,  58.589400f,  58.876500f,  59.163700f,  59.450900f,  59.738100f,  60.025300f,  60.312500f};

static float s_Illuminance_D50_min = 300.0f;
static float s_Illuminance_D50_max = 780.0f;
#define s_Illuminance_D50_samplesCount 97
static float s_Illuminance_D50[] = {
    0.019f,  1.035f,  2.051f,   4.914f,   7.778f,   11.263f,  14.748f,  16.348f,  17.948f,  19.479f,  21.010f,
    22.476f, 23.942f, 25.451f,  26.961f,  25.724f,  24.488f,  27.179f,  29.871f,  39.589f,  49.308f,  52.910f,
    56.513f, 58.273f, 60.034f,  58.926f,  57.818f,  66.321f,  74.825f,  81.036f,  87.247f,  88.930f,  90.612f,
    90.990f, 91.368f, 93.238f,  95.109f,  93.536f,  91.963f,  93.843f,  95.724f,  96.169f,  96.613f,  96.871f,
    97.129f, 99.614f, 102.099f, 101.427f, 100.755f, 101.536f, 102.317f, 101.159f, 100.000f, 98.868f,  97.735f,
    98.327f, 98.918f, 96.208f,  93.499f,  95.593f,  97.688f,  98.478f,  99.269f,  99.155f,  99.042f,  97.382f,
    95.722f, 97.290f, 98.857f,  97.262f,  95.667f,  96.929f,  98.190f,  100.597f, 103.003f, 101.068f, 99.133f,
    93.257f, 87.381f, 89.492f,  91.604f,  92.246f,  92.889f,  84.872f,  76.854f,  81.683f,  86.511f,  89.546f,
    92.580f, 85.405f, 78.230f,  67.961f,  57.692f,  70.307f,  82.923f,  80.599f,  78.274f};

static float *s_CIE_Observers_X[] = {s_CIE_1931_2deg_X, s_CIE_1964_10deg_X};
static float *s_CIE_Observers_Y[] = {s_CIE_1931_2deg_Y, s_CIE_1964_10deg_Y};
static float *s_CIE_Observers_Z[] = {s_CIE_1931_2deg_Z, s_CIE_1964_10deg_Z};
static float s_CIE_Observers_min[] = {s_CIE_1931_2deg_min, s_CIE_1964_10deg_min};
static float s_CIE_Observers_max[] = {s_CIE_1931_2deg_max, s_CIE_1964_10deg_max};
static int s_CIE_Observers_SamplesCount[] = {s_CIE_1931_2deg_samplesCount, s_CIE_1964_10deg_samplesCount};

static float *s_Illums[] = {s_Illuminance_D50, s_Illuminance_D65};
static float s_Illums_min[] = {s_Illuminance_D50_min, s_Illuminance_D65_min};
static float s_Illums_max[] = {s_Illuminance_D50_max, s_Illuminance_D65_max};
static int s_Illums_SamplesCount[] = {s_Illuminance_D50_samplesCount, s_Illuminance_D65_samplesCount};

// White Points
// { 1932-2° {x, y}, 1964-10° {x, y}, Temperature Kelvin }
static ImVec2 s_WhitePoints_Values[][2] = {
    {ImVec2(0.44757f, 0.40745f), ImVec2(0.45117f, 0.40594f)},// A:	incandescent / tungsten
    {ImVec2(0.34842f, 0.35161f), ImVec2(0.34980f, 0.35270f)},// B:	obsolete, direct sunlight at noon
    {ImVec2(0.31006f, 0.31616f), ImVec2(0.31039f, 0.31905f)},// C:	obsolete, average / North sky daylight
    {ImVec2(0.34567f, 0.35850f), ImVec2(0.34773f, 0.35952f)},// D50:	horizon light, ICC profile PCS
    {ImVec2(0.33242f, 0.34743f), ImVec2(0.33411f, 0.34877f)},// D55:	mid-morning / mid-afternoon daylight
    {ImVec2(0.31271f, 0.32902f), ImVec2(0.31382f, 0.33100f)},// D65:	noon daylight: television, sRGB color space
    {ImVec2(0.29902f, 0.31485f), ImVec2(0.29968f, 0.31740f)},// D75:	North sky daylight
    {ImVec2(0.28315f, 0.29711f), ImVec2(0.28327f, 0.30043f)},// D93:	high-efficiency blue phosphor monitors, BT.2035
    {ImVec2(0.33333f, 0.33333f), ImVec2(0.33333f, 0.33333f)},// E:	equal energy
    {ImVec2(0.31310f, 0.33727f), ImVec2(0.31811f, 0.33559f)},// F1:	daylight fluorescent
    {ImVec2(0.37208f, 0.37529f), ImVec2(0.37925f, 0.36733f)},// F2:	cool white fluorescent
    {ImVec2(0.40910f, 0.39430f), ImVec2(0.41761f, 0.38324f)},// F3:	white fluorescent
    {ImVec2(0.44018f, 0.40329f), ImVec2(0.44920f, 0.39074f)},// F4:	warm white fluorescent
    {ImVec2(0.31379f, 0.34531f), ImVec2(0.31975f, 0.34246f)},// F5:	daylight fluorescent
    {ImVec2(0.37790f, 0.38835f), ImVec2(0.38660f, 0.37847f)},// F6:	light white fluorescent
    {ImVec2(0.31292f, 0.32933f), ImVec2(0.31569f, 0.32960f)},// F7:	D65 simulator, daylight simulator
    {ImVec2(0.34588f, 0.35875f), ImVec2(0.34902f, 0.35939f)},// F8:	D50 simulator, Sylvania F40 Design 50
    {ImVec2(0.37417f, 0.37281f), ImVec2(0.37829f, 0.37045f)},// F9:	cool white deluxe fluorescent
    {ImVec2(0.34609f, 0.35986f), ImVec2(0.35090f, 0.35444f)},// F10:	Philips TL85, Ultralume 50
    {ImVec2(0.38052f, 0.37713f), ImVec2(0.38541f, 0.37123f)},// F11:	Philips TL84, Ultralume 40
    {ImVec2(0.43695f, 0.40441f), ImVec2(0.44256f, 0.39717f)} // F12:	Philips TL83, Ultralume 30
};
[[maybe_unused]] static float s_WhitePoints_Temperature[] = {
    2856.0f, 4874.0f, 6774.0f, 5003.0f, 5503.0f, 6504.0f, 7504.0f, 9305.0f, 5454.0f, 6430.0f, 4230.0f,
    3450.0f, 2940.0f, 6350.0f, 4150.0f, 6500.0f, 5000.0f, 4150.0f, 5000.0f, 4000.0f, 3000.0f};

// Color Space
static float s_ColorSpace_XYZ2RGB_AdobeRGB[] = {2.0413690f, -0.5649464f, -0.3446944f,  -0.9692660f, 1.8760108f,
                                                0.0415560f,  0.0134474f,  -0.1183897f, 1.0154096f};
static float s_ColorSpace_XYZ2RGB_AppleRGB[] = {2.9515373f, -1.2894116f, -0.4738445f, -1.0851093f, 1.9908566f,
                                                0.0372026f, 0.0854934f,  -0.2694964f, 1.0912975f};
static float s_ColorSpace_XYZ2RGB_Best[] = {1.7552599f, -0.4836786f, -0.2530000f, -0.5441336f, 1.5068789f,
                                            0.0215528f, 0.0063467f,  -0.0175761f, 1.2256959f};
static float s_ColorSpace_XYZ2RGB_Beta[] = {1.6832270f, -0.4282363f, -0.2360185f, -0.7710229f, 1.7065571f,
                                            0.0446900f, 0.0400013f,  -0.0885376f, 1.2723640f};
static float s_ColorSpace_XYZ2RGB_Bruce[] = {2.7454669f, -1.1358136f, -0.4350269f, -0.9692660f, 1.8760108f,
                                             0.0415560f, 0.0112723f,  -0.1139754f, 1.0132541f};
static float s_ColorSpace_XYZ2RGB_CIERGB[] = {2.3706743f, -0.9000405f, -0.4706338f, -0.5138850f, 1.4253036f,
                                              0.0885814f, 0.0052982f,  -0.0146949f, 1.0093968f};
static float s_ColorSpace_XYZ2RGB_ColorMatch[] = {2.6422874f, -1.2234270f, -0.3930143f, -1.1119763f, 2.0590183f,
                                                  0.0159614f, 0.0821699f,  -0.2807254f, 1.4559877f};
static float s_ColorSpace_XYZ2RGB_DonRGB4[] = {1.7603902f, -0.4881198f, -0.2536126f, -0.7126288f, 1.6527432f,
                                               0.0416715f, 0.0078207f,  -0.0347411f, 1.2447743f};
static float s_ColorSpace_XYZ2RGB_ECI[] = {1.7827618f,  -0.4969847f, -0.2690101f, -0.9593623f, 1.9477962f,
                                           -0.0275807f, 0.0859317f,  -0.1744674f, 1.3228273f};
static float s_ColorSpace_XYZ2RGB_EktaSpacePS5[] = {2.0043819f, -0.7304844f, -0.2450052f, -0.7110285f, 1.6202126f,
                                                    0.0792227f, 0.0381263f,  -0.0868780f, 1.2725438f};
static float s_ColorSpace_XYZ2RGB_NTSC[] = {1.9099961f,  -0.5324542f, -0.2882091f, -0.9846663f, 1.9991710f,
                                            -0.0283082f, 0.0583056f,  -0.1183781f, 0.8975535f};
static float s_ColorSpace_XYZ2RGB_PAL_SECAM[] = {3.0628971f, -1.3931791f, -0.4757517f, -0.9692660f, 1.8760108f,
                                                 0.0415560f, 0.0678775f,  -0.2288548f, 1.0693490f};
static float s_ColorSpace_XYZ2RGB_ProPhoto[] = {1.3459433f, -0.2556075f, -0.0511118f, -0.5445989f, 1.5081673f,
                                                0.0205351f, 0.0000000f,  0.0000000f,  1.2118128f};
static float s_ColorSpace_XYZ2RGB_SMPTE_C[] = {3.5053960f, -1.7394894f, -0.5439640f, -1.0690722f, 1.9778245f,
                                               0.0351722f, 0.0563200f,  -0.1970226f, 1.0502026f};
static float s_ColorSpace_XYZ2RGB_sRGB[] = {3.2404542f, -1.5371385f, -0.4985314f, -0.9692660f, 1.8760108f,
                                            0.0415560f, 0.0556434f,  -0.2040259f, 1.0572252f};
static float s_ColorSpace_XYZ2RGB_WideGamutRGB[] = {1.4628067f, -0.1840623f, -0.2743606f, -0.5217933f, 1.4472381f,
                                                    0.0677227f, 0.0349342f,  -0.0968930f, 1.2884099f};
static float s_ColorSpace_XYZ2RGB_Rec2020[] = {1.7166512f, -0.3556708f, -0.2533663f, -0.6666844f, 1.6164812f,
                                               0.0157685f, 0.0176399f,  -0.0427706f, 0.9421031f};
static float *s_ColorSpace_XYZ2RGB[] = {
    s_ColorSpace_XYZ2RGB_AdobeRGB,     s_ColorSpace_XYZ2RGB_AppleRGB, s_ColorSpace_XYZ2RGB_Best,
    s_ColorSpace_XYZ2RGB_Beta,         s_ColorSpace_XYZ2RGB_Bruce,    s_ColorSpace_XYZ2RGB_CIERGB,
    s_ColorSpace_XYZ2RGB_ColorMatch,   s_ColorSpace_XYZ2RGB_DonRGB4,  s_ColorSpace_XYZ2RGB_ECI,
    s_ColorSpace_XYZ2RGB_EktaSpacePS5, s_ColorSpace_XYZ2RGB_NTSC,     s_ColorSpace_XYZ2RGB_PAL_SECAM,
    s_ColorSpace_XYZ2RGB_ProPhoto,     s_ColorSpace_XYZ2RGB_SMPTE_C,  s_ColorSpace_XYZ2RGB_sRGB,
    s_ColorSpace_XYZ2RGB_WideGamutRGB, s_ColorSpace_XYZ2RGB_Rec2020};
static float s_ColorSpace_Gamma[] = {2.2f, 1.8f, 2.2f, 2.2f, 2.2f, 2.2f, 1.8f, 2.2f, 1.0f,
                                     2.2f, 2.2f, 2.2f, 1.8f, 2.2f, 2.2f, 2.2f, 2.2f};
// xy: { {xy}:RR, {xy}:GG, {xy}:BB }
static ImVec2 s_ColorSpace_Primaries[][3] = {
    {ImVec2(0.6400f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1500f, 0.0600f)},// AdobeRBG
    {ImVec2(0.6250f, 0.3400f), ImVec2(0.2800f, 0.5950f), ImVec2(0.1550f, 0.0700f)},// AppleRGB
    {ImVec2(0.7347f, 0.2653f), ImVec2(0.2150f, 0.7750f), ImVec2(0.1300f, 0.0350f)},// Best
    {ImVec2(0.6888f, 0.3112f), ImVec2(0.1986f, 0.7551f), ImVec2(0.1265f, 0.0352f)},// Beta
    {ImVec2(0.6400f, 0.3300f), ImVec2(0.2800f, 0.6500f), ImVec2(0.1500f, 0.0600f)},// Bruce
    {ImVec2(0.7350f, 0.2650f), ImVec2(0.2740f, 0.7170f), ImVec2(0.1670f, 0.0090f)},// CIERGB
    {ImVec2(0.6300f, 0.3400f), ImVec2(0.2950f, 0.6050f), ImVec2(0.1500f, 0.0750f)},// ColorMatch
    {ImVec2(0.6960f, 0.3000f), ImVec2(0.2150f, 0.7650f), ImVec2(0.1300f, 0.0350f)},// DonRGB4
    {ImVec2(0.6700f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1400f, 0.0800f)},// ECI
    {ImVec2(0.6950f, 0.3050f), ImVec2(0.2600f, 0.7000f), ImVec2(0.1100f, 0.0050f)},// EktaSpacePS5
    {ImVec2(0.6700f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1400f, 0.0800f)},// NTSC
    {ImVec2(0.6400f, 0.3300f), ImVec2(0.2900f, 0.6000f), ImVec2(0.1500f, 0.0600f)},// PAL/SECAM
    {ImVec2(0.7347f, 0.2653f), ImVec2(0.1596f, 0.8404f), ImVec2(0.0366f, 0.0001f)},// ProPhoto
    {ImVec2(0.6300f, 0.3400f), ImVec2(0.3100f, 0.5950f), ImVec2(0.1550f, 0.0700f)},// SMPTE-C
    {ImVec2(0.6400f, 0.3300f), ImVec2(0.3000f, 0.6000f), ImVec2(0.1500f, 0.0600f)},// sRGB
    {ImVec2(0.7350f, 0.2650f), ImVec2(0.1150f, 0.8260f), ImVec2(0.1570f, 0.0180f)},// Wide Gamut
    {ImVec2(0.7080f, 0.2920f), ImVec2(0.1700f, 0.7970f), ImVec2(0.1310f, 0.0460f)} // Rec2020
};
static int s_ColorSpace_WhitePointIndex[] = {
    ImWidgetsWhitePointChromaticPlot_D65, ImWidgetsWhitePointChromaticPlot_D65, ImWidgetsWhitePointChromaticPlot_D50,
    ImWidgetsWhitePointChromaticPlot_D50, ImWidgetsWhitePointChromaticPlot_D65, ImWidgetsWhitePointChromaticPlot_E,
    ImWidgetsWhitePointChromaticPlot_D50, ImWidgetsWhitePointChromaticPlot_D50, ImWidgetsWhitePointChromaticPlot_D50,
    ImWidgetsWhitePointChromaticPlot_D50, ImWidgetsWhitePointChromaticPlot_C,   ImWidgetsWhitePointChromaticPlot_D65,
    ImWidgetsWhitePointChromaticPlot_D50, ImWidgetsWhitePointChromaticPlot_D65, ImWidgetsWhitePointChromaticPlot_D65,
    ImWidgetsWhitePointChromaticPlot_D50, ImWidgetsWhitePointChromaticPlot_D65};

//////////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////////
void ScaleData(ImGuiDataType data_type, void *p_data, double value) {
  switch (data_type) {
    case ImGuiDataType_S8: *reinterpret_cast<ImS8 *>(p_data) *= static_cast<ImS8>(value); break;
    case ImGuiDataType_U8: *reinterpret_cast<ImU8 *>(p_data) *= static_cast<ImU8>(value); break;
    case ImGuiDataType_S16: *reinterpret_cast<ImS16 *>(p_data) *= static_cast<ImS16>(value); break;
    case ImGuiDataType_U16: *reinterpret_cast<ImU16 *>(p_data) *= static_cast<ImU16>(value); break;
    case ImGuiDataType_S32: *reinterpret_cast<ImS32 *>(p_data) *= static_cast<ImS32>(value); break;
    case ImGuiDataType_U32: *reinterpret_cast<ImU32 *>(p_data) *= static_cast<ImU32>(value); break;
    case ImGuiDataType_S64: *reinterpret_cast<ImS64 *>(p_data) *= static_cast<ImS64>(value); break;
    case ImGuiDataType_U64: *reinterpret_cast<ImU64 *>(p_data) *= static_cast<ImU64>(value); break;
    case ImGuiDataType_Float: *reinterpret_cast<float *>(p_data) *= static_cast<float>(value); break;
    case ImGuiDataType_Double: *reinterpret_cast<double *>(p_data) *= value; break;
  }
}

bool IsNegativeScalar(ImGuiDataType data_type, ImU64 *src) {
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value = *reinterpret_cast<ImS8 *>(src);
      return value < 0;
    } break;
    case ImGuiDataType_S16: {
      ImS16 value = *reinterpret_cast<ImS16 *>(src);
      return value < 0;
    } break;
    case ImGuiDataType_S32: {
      ImS32 value = *reinterpret_cast<ImS32 *>(src);
      return value < 0l;
    } break;
    case ImGuiDataType_S64: {
      ImS64 value = *reinterpret_cast<ImS64 *>(src);
      return value < 0ll;
    } break;
    case ImGuiDataType_U8:
    case ImGuiDataType_U16:
    case ImGuiDataType_U32:
    case ImGuiDataType_U64: {
      return false;
    } break;
    case ImGuiDataType_Float: {
      float value = *reinterpret_cast<float *>(src);
      return value < 0.0f;
    } break;
    case ImGuiDataType_Double: {
      double value = *reinterpret_cast<double *>(src);
      return value < 0.0f;
    } break;
  }

  return false;
}

bool IsPositiveScalar(ImGuiDataType data_type, ImU64 *src) { return !IsNegativeScalar(data_type, src); }

template<typename TypeSrc>
ImU64 SetScalar(ImGuiDataType data_type, TypeSrc src) {
  ImU64 result;
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value = static_cast<ImS8>(src);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U8: {
      ImU8 value = static_cast<ImU8>(src);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S16: {
      ImS16 value = static_cast<ImS16>(src);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U16: {
      ImU16 value = static_cast<ImU16>(src);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S32: {
      ImS32 value = static_cast<ImS32>(src);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U32: {
      ImU32 value = static_cast<ImU32>(src);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S64: {
      ImS64 value = static_cast<ImS64>(src);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U64: {
      ImU64 value = static_cast<ImU64>(src);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_Float: {
      float value = static_cast<float>(src);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    case ImGuiDataType_Double: {
      double value = static_cast<double>(src);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
  }

  return result;
}

void EqualScalar(ImGuiDataType data_type, ImU64 *p_target, ImU64 *p_source) {
  switch (data_type) {
    case ImGuiDataType_S8: *reinterpret_cast<ImS8 *>(p_target) = *reinterpret_cast<ImS8 *>(p_source); break;
    case ImGuiDataType_U8: *reinterpret_cast<ImU8 *>(p_target) = *reinterpret_cast<ImU8 *>(p_source); break;
    case ImGuiDataType_S16: *reinterpret_cast<ImS16 *>(p_target) = *reinterpret_cast<ImS16 *>(p_source); break;
    case ImGuiDataType_U16: *reinterpret_cast<ImU16 *>(p_target) = *reinterpret_cast<ImU16 *>(p_source); break;
    case ImGuiDataType_S32: *reinterpret_cast<ImS32 *>(p_target) = *reinterpret_cast<ImS32 *>(p_source); break;
    case ImGuiDataType_U32: *reinterpret_cast<ImU64 *>(p_target) = *reinterpret_cast<ImU32 *>(p_source); break;
    case ImGuiDataType_S64: *reinterpret_cast<ImS64 *>(p_target) = *reinterpret_cast<ImS64 *>(p_source); break;
    case ImGuiDataType_U64: *reinterpret_cast<ImU64 *>(p_target) = *reinterpret_cast<ImU64 *>(p_source); break;
    case ImGuiDataType_Float: *reinterpret_cast<float *>(p_target) = *reinterpret_cast<float *>(p_source); break;
    case ImGuiDataType_Double: *reinterpret_cast<double *>(p_target) = *reinterpret_cast<double *>(p_source); break;
  }
}

float ScalarToFloat(ImGuiDataType data_type, ImU64 *p_source) {
  switch (data_type) {
    case ImGuiDataType_S8: return static_cast<float>(*reinterpret_cast<ImS8 *>(p_source));
    case ImGuiDataType_U8: return static_cast<float>(*reinterpret_cast<ImU8 *>(p_source));
    case ImGuiDataType_S16: return static_cast<float>(*reinterpret_cast<ImS16 *>(p_source));
    case ImGuiDataType_U16: return static_cast<float>(*reinterpret_cast<ImU16 *>(p_source));
    case ImGuiDataType_S32: return static_cast<float>(*reinterpret_cast<ImS32 *>(p_source));
    case ImGuiDataType_U32: return static_cast<float>(*reinterpret_cast<ImU32 *>(p_source));
    case ImGuiDataType_S64: return static_cast<float>(*reinterpret_cast<ImS64 *>(p_source));
    case ImGuiDataType_U64: return static_cast<float>(*reinterpret_cast<ImU64 *>(p_source));
    case ImGuiDataType_Float: return static_cast<float>(*reinterpret_cast<float *>(p_source));
    case ImGuiDataType_Double: return static_cast<float>(*reinterpret_cast<double *>(p_source));
  }

  return 0.0f;
}

ImU64 FloatToScalar(ImGuiDataType data_type, float f_value) {
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value = static_cast<ImS8>(f_value);
      return static_cast<ImU64>(value);
    }
    case ImGuiDataType_U8: {
      ImU8 value = static_cast<ImU8>(f_value);
      return static_cast<ImU64>(value);
    }
    case ImGuiDataType_S16: {
      ImS16 value = static_cast<ImS16>(f_value);
      return static_cast<ImU64>(value);
    }
    case ImGuiDataType_U16: {
      ImU16 value = static_cast<ImU16>(f_value);
      return static_cast<ImU64>(value);
    }
    case ImGuiDataType_S32: {
      ImS32 value = static_cast<ImS32>(f_value);
      return static_cast<ImU64>(value);
    }
    case ImGuiDataType_U32: {
      ImU32 value = static_cast<ImU32>(f_value);
      return static_cast<ImU64>(value);
    }
    case ImGuiDataType_S64: {
      ImS64 value = static_cast<ImS64>(f_value);
      return static_cast<ImU64>(value);
    }
    case ImGuiDataType_U64: {
      ImU64 value = static_cast<ImU64>(f_value);
      return static_cast<ImU64>(value);
    }
    case ImGuiDataType_Float: {
      float value = f_value;
      return *reinterpret_cast<ImU64 *>(reinterpret_cast<void *>(&value));
    }
    case ImGuiDataType_Double: {
      double value = static_cast<double>(f_value);
      return *reinterpret_cast<ImU64 *>(&value);
    }
  }

  return ImU64();
}

ImU64 AddScalar(ImGuiDataType data_type, void *p_a, void *p_b) {
  ImU64 result;
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value = *reinterpret_cast<ImS8 *>(p_a) + *static_cast<ImS8 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U8: {
      ImU8 value = *reinterpret_cast<ImU8 *>(p_a) + *static_cast<ImU8 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S16: {
      ImS16 value = *reinterpret_cast<ImS16 *>(p_a) + *static_cast<ImS16 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U16: {
      ImU16 value = *reinterpret_cast<ImU16 *>(p_a) + *static_cast<ImU16 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S32: {
      ImS32 value = *reinterpret_cast<ImS32 *>(p_a) + *static_cast<ImS32 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U32: {
      ImU32 value = *reinterpret_cast<ImU32 *>(p_a) + *static_cast<ImU32 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S64: {
      ImS64 value = *reinterpret_cast<ImS64 *>(p_a) + *static_cast<ImS64 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U64: {
      ImU64 value = *reinterpret_cast<ImU64 *>(p_a) + *static_cast<ImU64 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_Float: {
      float value = *reinterpret_cast<float *>(p_a) + *static_cast<float *>(p_b);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    case ImGuiDataType_Double: {
      double value = *reinterpret_cast<double *>(p_a) + *static_cast<double *>(p_b);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    default: throw std::exception();
  }

  return result;
}

ImU64 SubScalar(ImGuiDataType data_type, void *p_a, void *p_b) {
  ImU64 result = 0;
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value = *reinterpret_cast<ImS8 *>(p_a) - *static_cast<ImS8 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U8: {
      ImU8 value = *reinterpret_cast<ImU8 *>(p_a) - *static_cast<ImU8 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S16: {
      ImS16 value = *reinterpret_cast<ImS16 *>(p_a) - *static_cast<ImS16 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U16: {
      ImU16 value = *reinterpret_cast<ImU16 *>(p_a) - *static_cast<ImU16 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S32: {
      ImS32 value = *reinterpret_cast<ImS32 *>(p_a) - *static_cast<ImS32 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U32: {
      ImU32 value = *reinterpret_cast<ImU32 *>(p_a) - *static_cast<ImU32 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S64: {
      ImS64 value = *reinterpret_cast<ImS64 *>(p_a) - *static_cast<ImS64 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U64: {
      ImU64 value = *reinterpret_cast<ImU64 *>(p_a) - *static_cast<ImU64 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_Float: {
      float value = *reinterpret_cast<float *>(p_a) - *static_cast<float *>(p_b);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    case ImGuiDataType_Double: {
      double value = *reinterpret_cast<double *>(p_a) - *static_cast<double *>(p_b);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
  }

  return result;
}

ImU64 MulScalar(ImGuiDataType data_type, void *p_a, void *p_b) {
  ImU64 result;
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value = *reinterpret_cast<ImS8 *>(p_a) * *static_cast<ImS8 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U8: {
      ImU8 value = *reinterpret_cast<ImU8 *>(p_a) * *static_cast<ImU8 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S16: {
      ImS16 value = *reinterpret_cast<ImS16 *>(p_a) * *static_cast<ImS16 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U16: {
      ImU16 value = *reinterpret_cast<ImU16 *>(p_a) * *static_cast<ImU16 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S32: {
      ImS32 value = *reinterpret_cast<ImS32 *>(p_a) * *static_cast<ImS32 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U32: {
      ImU32 value = *reinterpret_cast<ImU32 *>(p_a) * *static_cast<ImU32 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S64: {
      ImS64 value = *reinterpret_cast<ImS64 *>(p_a) * *static_cast<ImS64 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U64: {
      ImU64 value = *reinterpret_cast<ImU64 *>(p_a) * *static_cast<ImU64 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_Float: {
      float value = *reinterpret_cast<float *>(p_a) * *static_cast<float *>(p_b);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    case ImGuiDataType_Double: {
      double value = *reinterpret_cast<double *>(p_a) * *static_cast<double *>(p_b);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    default: throw std::exception();
  }

  return result;
}

ImU64 DivScalar(ImGuiDataType data_type, void *p_a, void *p_b) {
  ImU64 result;
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value = *reinterpret_cast<ImS8 *>(p_a) / *static_cast<ImS8 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U8: {
      ImU8 value = *reinterpret_cast<ImU8 *>(p_a) / *static_cast<ImU8 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S16: {
      ImS16 value = *reinterpret_cast<ImS16 *>(p_a) / *static_cast<ImS16 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U16: {
      ImU16 value = *reinterpret_cast<ImU16 *>(p_a) / *static_cast<ImU16 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S32: {
      ImS32 value = *reinterpret_cast<ImS32 *>(p_a) / *static_cast<ImS32 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U32: {
      ImU32 value = *reinterpret_cast<ImU32 *>(p_a) / *static_cast<ImU32 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S64: {
      ImS64 value = *reinterpret_cast<ImS64 *>(p_a) / *static_cast<ImS64 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U64: {
      ImU64 value = *reinterpret_cast<ImU64 *>(p_a) / *static_cast<ImU64 *>(p_b);
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_Float: {
      float value = *reinterpret_cast<float *>(p_a) / *static_cast<float *>(p_b);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    case ImGuiDataType_Double: {
      double value = *reinterpret_cast<double *>(p_a) / *static_cast<double *>(p_b);
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    default: throw std::exception();
  }

  return result;
}

ImU64 ClampScalar(ImGuiDataType data_type, void *p_value, void *p_min, void *p_max) {
  ImU64 result = 0;
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value =
          ImClamp(*reinterpret_cast<ImS8 *>(p_value), *static_cast<ImS8 *>(p_min), *static_cast<ImS8 *>(p_max));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U8: {
      ImU8 value =
          ImClamp(*reinterpret_cast<ImU8 *>(p_value), *static_cast<ImU8 *>(p_min), *static_cast<ImU8 *>(p_max));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S16: {
      ImS16 value =
          ImClamp(*reinterpret_cast<ImS16 *>(p_value), *static_cast<ImS16 *>(p_min), *static_cast<ImS16 *>(p_max));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U16: {
      ImU16 value =
          ImClamp(*reinterpret_cast<ImU16 *>(p_value), *static_cast<ImU16 *>(p_min), *static_cast<ImU16 *>(p_max));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S32: {
      ImS32 value =
          ImClamp(*reinterpret_cast<ImS32 *>(p_value), *static_cast<ImS32 *>(p_min), *static_cast<ImS32 *>(p_max));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U32: {
      ImU32 value =
          ImClamp(*reinterpret_cast<ImU32 *>(p_value), *static_cast<ImU32 *>(p_min), *static_cast<ImU32 *>(p_max));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S64: {
      ImS64 value =
          ImClamp(*reinterpret_cast<ImS64 *>(p_value), *static_cast<ImS64 *>(p_min), *static_cast<ImS64 *>(p_max));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U64: {
      ImU64 value =
          ImClamp(*reinterpret_cast<ImU64 *>(p_value), *static_cast<ImU64 *>(p_min), *static_cast<ImU64 *>(p_max));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_Float: {
      float value =
          ImClamp(*reinterpret_cast<float *>(p_value), *static_cast<float *>(p_min), *static_cast<float *>(p_max));
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    case ImGuiDataType_Double: {
      double value =
          ImClamp(*reinterpret_cast<double *>(p_value), *static_cast<double *>(p_min), *static_cast<double *>(p_max));
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
  }

  return result;
}

ImU64 Normalize01(ImGuiDataType data_type, void *p_value, void *p_min, void *p_max) {
  ImU64 result = 0;
  switch (data_type) {
    case ImGuiDataType_S8: {
      ImS8 value = (*reinterpret_cast<ImS8 *>(p_value) - *static_cast<ImS8 *>(p_min))
          / (*static_cast<ImS8 *>(p_max) - *static_cast<ImS8 *>(p_min));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U8: {
      ImU8 value = (*reinterpret_cast<ImU8 *>(p_value) - *static_cast<ImU8 *>(p_min))
          / (*static_cast<ImU8 *>(p_max) - *static_cast<ImU8 *>(p_min));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S16: {
      ImS16 value = (*reinterpret_cast<ImS16 *>(p_value) - *static_cast<ImS16 *>(p_min))
          / (*static_cast<ImS16 *>(p_max) - *static_cast<ImS16 *>(p_min));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U16: {
      ImU16 value = (*reinterpret_cast<ImU16 *>(p_value) - *static_cast<ImU16 *>(p_min))
          / (*static_cast<ImU16 *>(p_max) - *static_cast<ImU16 *>(p_min));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S32: {
      ImS32 value = (*reinterpret_cast<ImS32 *>(p_value) - *static_cast<ImS32 *>(p_min))
          / (*static_cast<ImS32 *>(p_max) - *static_cast<ImS32 *>(p_min));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U32: {
      ImU32 value = (*reinterpret_cast<ImU32 *>(p_value) - *static_cast<ImU32 *>(p_min))
          / (*static_cast<ImU32 *>(p_max) - *static_cast<ImU32 *>(p_min));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_S64: {
      ImS64 value = (*reinterpret_cast<ImS64 *>(p_value) - *static_cast<ImS64 *>(p_min))
          / (*static_cast<ImS64 *>(p_max) - *static_cast<ImS64 *>(p_min));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_U64: {
      ImU64 value = (*reinterpret_cast<ImU64 *>(p_value) - *static_cast<ImU64 *>(p_min))
          / (*static_cast<ImU64 *>(p_max) - *static_cast<ImU64 *>(p_min));
      result = static_cast<ImU64>(value);
    } break;
    case ImGuiDataType_Float: {
      float value = (*reinterpret_cast<float *>(p_value) - *static_cast<float *>(p_min))
          / (*static_cast<float *>(p_max) - *static_cast<float *>(p_min));
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
    case ImGuiDataType_Double: {
      double value = (*reinterpret_cast<double *>(p_value) - *static_cast<double *>(p_min))
          / (*static_cast<double *>(p_max) - *static_cast<double *>(p_min));
      result = *reinterpret_cast<ImU64 *>(&value);
    } break;
  }

  return result;
}

float Dot3(float x0, float x1, float x2, float *vec3) { return x0 * vec3[0] + x1 * vec3[1] + x2 * vec3[2]; }

void Mat33MulV(float *z0, float *z1, float *z2, float x, float y, float z, float *mat) {
  *z0 = Dot3(x, y, z, &mat[0]);
  *z1 = Dot3(x, y, z, &mat[3]);
  *z2 = Dot3(x, y, z, &mat[6]);
}

void MemoryString(std::string &sResult, ImU64 const uMemoryByte) {
  if (uMemoryByte < ImWidgets_Kibi) {
    sResult = std::to_string(static_cast<float>(uMemoryByte)) + " B";
  } else if (uMemoryByte < ImWidgets_Mibi) {
    sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidgets_Kibi)) + " KiB";
  } else if (uMemoryByte < ImWidgets_Gibi) {
    sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidgets_Mibi)) + " MiB";
  } else if (uMemoryByte < ImWidgets_Tebi) {
    sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidgets_Gibi)) + " GiB";
  } else if (uMemoryByte < ImWidgets_Pebi) {
    sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidgets_Tebi)) + " TiB";
  }
}

void TimeString(std::string &sResult, ImU64 const uNanoseconds) {
  std::chrono::nanoseconds oDuration(uNanoseconds);

  typedef std::chrono::duration<ImU64, std::ratio_multiply<std::chrono::hours::period, std::ratio<8>>::type>
      Days;// UTC: +8:00

  Days oDays = std::chrono::duration_cast<Days>(oDuration);
  oDuration -= oDays;
  auto oHours = std::chrono::duration_cast<std::chrono::hours>(oDuration);
  oDuration -= oHours;
  auto oMinutes = std::chrono::duration_cast<std::chrono::minutes>(oDuration);
  oDuration -= oMinutes;
  auto oSeconds = std::chrono::duration_cast<std::chrono::seconds>(oDuration);
  oDuration -= oSeconds;
  auto oMilliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(oDuration);
  oDuration -= oMilliseconds;
  auto oMicroseconds = std::chrono::duration_cast<std::chrono::microseconds>(oDuration);
  oDuration -= oMicroseconds;
  auto oNanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(oDuration);

  ImU64 const uNanoSecondsCountRaw = oNanoseconds.count();
  ImU64 const uNanoSecondsCount = uNanoSecondsCountRaw <= 100ull ? 0ull : uNanoSecondsCountRaw;

  sResult.clear();
  if (oDays.count() > 0) {
    sResult = std::to_string(oDays.count()) + " d : " + std::to_string(oHours.count())
        + " h : " + std::to_string(oMinutes.count()) + " min : " + std::to_string(oSeconds.count())
        + " s : " + std::to_string(oMilliseconds.count()) + " ms : " +
        //std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
        std::to_string(oMicroseconds.count()) + " us";//: " +
    //std::to_string( uNanoSecondsCount )		+ " ns";
  } else if (oHours.count() > 0) {
    sResult = std::to_string(oHours.count()) + " h : " + std::to_string(oMinutes.count())
        + " min : " + std::to_string(oSeconds.count()) + " s : " + std::to_string(oMilliseconds.count()) + " ms : " +
        //std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
        std::to_string(oMicroseconds.count()) + " us";//: " +
    //std::to_string( uNanoSecondsCount )		+ " ns";
  } else if (oMinutes.count() > 0) {
    sResult = std::to_string(oMinutes.count()) + " min : " + std::to_string(oSeconds.count())
        + " s : " + std::to_string(oMilliseconds.count()) + " ms : " +
        //std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
        std::to_string(oMicroseconds.count()) + " us";//: " +
    //std::to_string( uNanoSecondsCount )		+ " ns";
  } else if (oSeconds.count() > 0) {
    sResult = std::to_string(oSeconds.count()) + " s : " + std::to_string(oMilliseconds.count()) + " ms : " +
        //std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
        std::to_string(oMicroseconds.count()) + " us";//: " +
    //std::to_string( uNanoSecondsCount )		+ " ns";
  } else if (oMilliseconds.count() > 0) {
    sResult = std::to_string(oMilliseconds.count()) + " ms : " +
        //std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
        std::to_string(oMicroseconds.count()) + " us";//: " +
    //std::to_string( uNanoSecondsCount )		+ " ns";
  } else if (oMicroseconds.count() > 0) {
    sResult =                                         //std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
        std::to_string(oMicroseconds.count()) + " us";//: " +
    //std::to_string( uNanoSecondsCount )		+ " ns";
  } else                                              //if ( oNanoseconds.count() > 0 )
  {
    sResult = std::to_string(uNanoSecondsCount) + " ns";
  }
}

float Dist2(ImVec2 const v, ImVec2 const w) {
  //return Sqr(v.x - w.x) + Sqr(v.y - w.y);
  return ImLengthSqr(v - w);
}
float DistOnSegmentSqr(ImVec2 const p, ImVec2 const v, ImVec2 const w) {
  float l2 = Dist2(v, w);
  //if (l2 == 0.0f)
  //	return 0.0f;

  float t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;

  return ImSaturate(t) * Dist2(w, v);
}
float DistToSegmentSqr(ImVec2 const p, ImVec2 const v, ImVec2 const w) {
  //float l2 = Dist2(v, w);
  ////if (l2 == 0.0f)
  ////	return Dist2(p, v);
  //
  //float t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
  //t = ImSaturate(t);
  //
  //return Dist2(p, ImVec2(v.x + t * (w.x - v.x),
  //					   v.y + t * (w.y - v.y)));

  float const lDx = v.x - w.x;
  float const lDy = v.y - w.y;

  float const dx = v.x - p.x;
  float const dy = v.y - p.y;

  float const l2 = ImSqrt(ImLengthSqr(w - v));

  return ImAbs(lDx * dy - lDy * dx) / l2;
}
float Side(ImVec2 const src, ImVec2 const tgt, ImVec2 const pts) {
  ImVec2 vDir = tgt - src;
  ImVec2 vVec = pts - src;

  float zCross = vDir.x * vVec.y - vDir.y * vVec.x;

  return zCross >= 0.0f ? 1.0f : -1.0f;
}
ImVec2 Saturatev(ImVec2 const v) { return ImVec2(ImSaturate(v.x), ImSaturate(v.y)); }
ImVec2 Clampv(ImVec2 const v, ImVec2 const min, ImVec2 const max) {
  return ImVec2(ImClamp(v.x, min.x, max.x), ImClamp(v.y, min.y, max.y));
}
float Rescale01(float const x, float const min, float const max) { return (x - min) / (max - min); }
ImVec2 Rescale01v(ImVec2 const v, ImVec2 const min, ImVec2 const max) {
  return ImVec2(Rescale01(v.x, min.x, max.x), Rescale01(v.y, min.y, max.y));
}
float Rescale(float const x, float const min, float const max, float const newMin, float const newMax) {
  return Rescale01(x, min, max) * (newMax - newMin) + newMin;
}
ImVec2 Rescalev(ImVec2 const x, ImVec2 const min, ImVec2 const max, ImVec2 const newMin, ImVec2 const newMax) {
  ImVec2 const vNorm = Rescale01v(x, min, max);
  return ImVec2(vNorm.x * (newMax.x - newMin.x) + newMin.x, vNorm.y * (newMax.y - newMin.y) + newMin.y);
}
float Sign(float x) { return x < 0.0f ? -1.0f : 1.0f; }

//////////////////////////////////////////////////////////////////////////
// Widgets
//////////////////////////////////////////////////////////////////////////
void CenterNextItem(ImVec2 nextItemSize) {
  float const width = ImGui::GetContentRegionAvail().x;
  ImGui::Dummy(ImVec2((width - nextItemSize.x) * 0.5f, nextItemSize.y));
  ImGui::SameLine();
}


bool DragLengthScalar(const char *label, ImGuiDataType data_type, void *p_data, ImWidgetsLengthUnit *p_defaultUnit,
                      float v_speed, const void *p_min, const void *p_max, ImGuiSliderFlags flags) {
  bool modified = false;

  ImWidgetsLengthUnit &defaultUnit = *p_defaultUnit;

  ImVec2 curPos = ImGui::GetCursorScreenPos();

  //std::string format = std::string(ImGui::DataTypeGetInfo(data_type)->PrintFmt);
  std::string format = "%.3f";
  if (ImGui::Button("<", ImVec2(16.0f, 0.0f))) {
    --defaultUnit;
    if (defaultUnit < 0) defaultUnit = ImWidgetsLengthUnit_COUNT - 1;
  }
  ImGui::SameLine();
  if (defaultUnit == ImWidgetsLengthUnit_Imperial) {
    ScaleData(data_type, p_data, 0.28084);
    format += " ft";
  } else {
    format += " m";
  }
  float const width = ImGui::GetContentRegionAvail().x;
  ImGui::SetNextItemWidth(width * 0.5f - 32.0f);
  modified |= ImGui::DragScalar(label, data_type, p_data, v_speed, p_min, p_max, format.c_str(), flags);

  ImDrawList *pDrawList = ImGui::GetWindowDrawList();
  ImGui::SetWindowFontScale(1.0f);
  [[maybe_unused]] ImVec2 const vTextSize =
      ImGui::CalcTextSize(defaultUnit == ImWidgetsLengthUnit_Metric ? "meter" : "feet");
  ImVec2 itemSize = ImGui::GetItemRectSize();
  pDrawList->AddText(curPos + ImVec2(itemSize.x * 0.5f + 16.0f, ImGui::GetTextLineHeight()),
                     ImGui::GetColorU32(ImGuiCol_Text), defaultUnit == ImWidgetsLengthUnit_Metric ? "meter" : "feet");
  ImGui::SetWindowFontScale(1.0f);

  if (defaultUnit == ImWidgetsLengthUnit_Imperial) { ScaleData(data_type, p_data, 1.0 / 0.28084); }
  ImGui::SameLine();
  if (ImGui::Button(">", ImVec2(16.0f, 0.0f))) {
    ++defaultUnit;
    defaultUnit %= ImWidgetsLengthUnit_COUNT;
  }

  ImGui::Dummy(ImVec2(0.0f, ImGui::GetTextLineHeight()));

  return modified;
}

bool InputVec2(char const *pLabel, ImVec2 *pValue, ImVec2 vMinValue, ImVec2 vMaxValue, float const fScale /*= 1.0f*/) {
  return Slider2DScalar(pLabel, ImGuiDataType_Float, &pValue->x, &pValue->y, &vMinValue.x, &vMaxValue.x, &vMinValue.y,
                        &vMaxValue.y, fScale);
}

bool InputVec3(char const *pLabel, ImVec4 *pValue, ImVec4 const vMinValue, ImVec4 const vMaxValue,
               float const fScale /*= 1.0f*/) {
  return SliderScalar3D(pLabel, &pValue->x, &pValue->y, &pValue->z, vMinValue.x, vMaxValue.x, vMinValue.y, vMaxValue.y,
                        vMinValue.z, vMaxValue.z, fScale);
}

bool RangeSelect2D(char const *pLabel, float *pCurMinX, float *pCurMinY, float *pCurMaxX, float *pCurMaxY,
                   float const fBoundMinX, float const fBoundMinY, float const fBoundMaxX, float const fBoundMaxY,
                   ImVec2 size /*= 1.0f*/) {
  //EMV_ASSERT(fBoundMinX < fBoundMaxX);
  //EMV_ASSERT(fBoundMinY < fBoundMaxY);

  float &fCurMinX = *pCurMinX;
  float &fCurMinY = *pCurMinY;
  float &fCurMaxX = *pCurMaxX;
  float &fCurMaxY = *pCurMaxY;

  //EMV_ASSERT(fCurMinX < fCurMaxX);
  //EMV_ASSERT(fCurMinY < fCurMaxY);

  float const fDeltaBoundX = fBoundMaxX - fBoundMinX;
  float const fDeltaBoundY = fBoundMaxY - fBoundMinY;

  float const fDeltaX = fCurMaxX - fCurMinX;
  float const fDeltaY = fCurMaxY - fCurMinY;

  float const fScaleX = fDeltaX / fDeltaBoundX;
  float const fScaleY = fDeltaY / fDeltaBoundY;
  float const fScaleMinX = Rescale01(fCurMinX, fBoundMinX, fBoundMaxX);
  float const fScaleMinY = Rescale01(fCurMinY, fBoundMinY, fBoundMaxY);
  float const fScaleMaxX = Rescale01(fCurMaxX, fBoundMinX, fBoundMaxX);
  float const fScaleMaxY = Rescale01(fCurMaxY, fBoundMinY, fBoundMaxY);

  ImGuiID const iID = ImGui::GetID(pLabel);

  ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;


  if (size.x == 0) {
    float const vSizeFull = (ImGui::GetContentRegionAvail().x - vSizeSubstract.x);
    size.x = vSizeFull;
  }
  if (size.y == 0) {
    float const vSizeFull = (ImGui::GetContentRegionAvail().x - vSizeSubstract.x);
    size.y = vSizeFull;
  }

  const auto vSize = size;

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos + vHeightOffset, vPos + vSize + vHeightOffset);

  constexpr float fCursorOff = 10.0f;
  [[maybe_unused]] float const fXLimit = fCursorOff / oRect.GetWidth();
  [[maybe_unused]] float const fYLimit = fCursorOff / oRect.GetHeight();

  ImVec2 const vCursorPos((oRect.Max.x - oRect.Min.x) * fScaleX + oRect.Min.x,
                          (oRect.Max.y - oRect.Min.y) * fScaleY + oRect.Min.y);

  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vHeightOffset);

  //ImGui::Text(pLabel);

  ImGui::PushID(iID);
  ImU32 const uFrameCol = ImGui::GetColorU32(ImGuiCol_FrameBg);
  ImU32 const uFrameZoneCol = ImGui::GetColorU32(ImGuiCol_FrameBgActive);

  [[maybe_unused]] ImVec2 const vOriginPos = ImGui::GetCursorScreenPos();
  ImGui::RenderFrame(oRect.Min, oRect.Max, uFrameCol, false, 0.0f);
  bool bModified = false;
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImDrawList *pDrawList = ImGui::GetWindowDrawList();

  ImVec4 const vBlue(70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f);// TODO: choose from style
  [[maybe_unused]] ImVec4 const vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f,
                                        1.0f);// TODO: choose from style

  ImS32 const uBlue = ImGui::GetColorU32(vBlue);
  ImS32 const uOrange = ImGui::GetColorU32(vOrange);

  [[maybe_unused]] constexpr float fBorderThickness = 2.0f;
  constexpr float fLineThickness = 3.0f;
  constexpr float fHandleRadius = 7.0f;
  [[maybe_unused]] constexpr float fHandleOffsetCoef = 2.0f;

  float const fRegMinX = ImLerp(oRect.Min.x, oRect.Max.x, fScaleMinX);
  float const fRegMinY = ImLerp(oRect.Min.y, oRect.Max.y, fScaleMinY);
  float const fRegMaxX = ImLerp(oRect.Min.x, oRect.Max.x, fScaleMaxX);
  float const fRegMaxY = ImLerp(oRect.Min.y, oRect.Max.y, fScaleMaxY);

  ImRect oRegionRect(fRegMinX, fRegMinY, fRegMaxX, fRegMaxY);

  ImVec2 vMinCursorPos(fRegMinX, fRegMinY);
  ImVec2 vMaxCursorPos(fRegMaxX, fRegMaxY);

  float const fRegWidth = oRegionRect.GetWidth();
  ImRect oWidthHandle(ImVec2(vMinCursorPos.x + 0.25f * fRegWidth, oRect.Min.y - 0.5f * fCursorOff),
                      ImVec2(vMaxCursorPos.x - 0.25f * fRegWidth, oRect.Min.y + 0.5f * fCursorOff));
  float const fRegHeight = oRegionRect.GetHeight();
  ImRect oHeightHandle(ImVec2(oRect.Min.x - 0.5f * fCursorOff, vMinCursorPos.y + 0.25f * fRegHeight),
                       ImVec2(oRect.Min.x + 0.5f * fCursorOff, vMaxCursorPos.y - 0.25f * fRegHeight));

  //pDrawList->AddRect(oRect.Min, oRect.Max, uBlue, 0.0f, 0, fBorderThickness);
  //pDrawList->AddRect(oRegionRect.Min, oRegionRect.Max, uOrange, 0.0f, 0, fLineThickness);

  ImGui::RenderFrame(oRegionRect.Min, oRegionRect.Max, uFrameZoneCol, false, 0.0f);

  pDrawList->AddNgonFilled(vMinCursorPos, 5.0f, uBlue, 4);
  pDrawList->AddNgonFilled(vMaxCursorPos, 5.0f, uBlue, 4);

  ImRect oDragZone(oRegionRect.Min + ImVec2(fCursorOff, fCursorOff) + vSecurity,
                   oRegionRect.Max - ImVec2(fCursorOff, fCursorOff) - vSecurity);
  //if (oDragZone.IsInverted())
  //{
  //	oDragZone.Min = ImVec2();
  //	oDragZone.Max = ImVec2();
  //}

  //if (ImGui::IsMouseDown(ImGuiMouseButton_Left) &&
  //	ImGui::IsMouseHoveringRect(vMinCursorPos - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vMinCursorPos + ImVec2(fHandleRadius, fHandleRadius) + vSecurity))

  ImRect vDragBBMin(vMinCursorPos - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                    vMinCursorPos + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  ImRect vDragBBMax(vMaxCursorPos - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                    vMaxCursorPos + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  ImRect vDragHandleMin(oWidthHandle.Min - ImVec2(fCursorOff, fCursorOff) - vSecurity,
                        oWidthHandle.Max + ImVec2(fCursorOff, fCursorOff) + vSecurity);
  ImRect vDragHandleHeight(oHeightHandle.Min - ImVec2(fCursorOff, fCursorOff) - vSecurity,
                           oHeightHandle.Max + ImVec2(fCursorOff, fCursorOff) + vSecurity);
  ImRect vDragRect(oRegionRect.Min, oRegionRect.Max);

  // TODO:
  float const fArbitrarySpeedScaleBar = 0.0125f;

  bool hovered;
  bool held;
  [[maybe_unused]] bool pressed = ImGui::ButtonBehavior(vDragBBMin, ImGui::GetID("##Zone"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vLocalCursorPos = ImGui::GetMousePos();

    ImVec2 newVal = Rescalev(vLocalCursorPos, ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(oRect.Max.x, oRect.Max.y),
                             ImVec2(fBoundMinX, fBoundMinY), ImVec2(fBoundMaxX, fBoundMaxY));

    newVal.x = ImClamp(newVal.x, fBoundMinX, *pCurMaxX);
    newVal.y = ImClamp(newVal.y, fBoundMinY, *pCurMaxY);

    *pCurMinX = newVal.x;
    *pCurMinY = newVal.y;

    bModified = true;
  } else {
    //if (ImGui::IsMouseDown(ImGuiMouseButton_Left) &&
    //	ImGui::IsMouseHoveringRect(vMaxCursorPos - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vMaxCursorPos + ImVec2(fHandleRadius, fHandleRadius) + vSecurity))
    pressed = ImGui::ButtonBehavior(vDragBBMax, ImGui::GetID("##Zone"), &hovered, &held);
    if (hovered && held) {
      ImVec2 const vLocalCursorPos = ImGui::GetMousePos();

      ImVec2 newVal = Rescalev(vLocalCursorPos, ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(oRect.Max.x, oRect.Max.y),
                               ImVec2(fBoundMinX, fBoundMinY), ImVec2(fBoundMaxX, fBoundMaxY));

      newVal.x = ImClamp(newVal.x, *pCurMinX, fBoundMaxX);
      newVal.y = ImClamp(newVal.y, *pCurMinY, fBoundMaxY);

      *pCurMaxX = newVal.x;
      *pCurMaxY = newVal.y;

      bModified = true;
    } else {
      //if ((ImGui::IsMouseDown(ImGuiMouseButton_Left) || ImGui::IsMouseDown(ImGuiMouseButton_Right)) &&
      //	ImGui::IsMouseHoveringRect(oWidthHandle.Min - ImVec2(fCursorOff, fCursorOff) - vSecurity, oWidthHandle.Max + ImVec2(fCursorOff, fCursorOff) + vSecurity))
      pressed = ImGui::ButtonBehavior(vDragHandleMin, ImGui::GetID("##Zone"), &hovered, &held);
      if (hovered && held) {
        constexpr float fSpeedHandleWidth = 0.125f;
        float fDeltaWidth = oWidthHandle.GetCenter().x - ImGui::GetMousePos().x;
        // Apply Soft-Threshold
        //fDeltaWidth = fSpeedHandleWidth*Sign(fDeltaWidth)*std::max(std::abs(fDeltaWidth) - 0.5f*fCursorOff, 0.0f);

        fDeltaWidth = fSpeedHandleWidth * ImClamp(fDeltaWidth, -0.5f * oRect.GetWidth(), 0.5f * oRect.GetWidth());

        float fDeltaWidthValue = Rescale(fDeltaWidth, -0.5f * oRect.GetWidth(), 0.5f * oRect.GetWidth(),
                                         -0.5f * (fBoundMaxX - fBoundMinX), 0.5f * (fBoundMaxX - fBoundMinX));

        if (ImGui::IsMouseDown(ImGuiMouseButton_Right)) {
          *pCurMinX = ImClamp(*pCurMinX + fArbitrarySpeedScaleBar * fDeltaWidthValue, fBoundMinX, *pCurMaxX);
          *pCurMaxX = ImClamp(*pCurMaxX - fArbitrarySpeedScaleBar * fDeltaWidthValue, *pCurMinX, fBoundMaxX);
        } else {
          if (*pCurMinX <= fBoundMinX && fDeltaWidthValue > 0.0f) {
            fDeltaWidthValue = 0.0f;
          } else if (*pCurMaxX >= fBoundMaxX && fDeltaWidthValue < 0.0f) {
            fDeltaWidthValue = 0.0f;
          }

          *pCurMinX = ImClamp(*pCurMinX - fDeltaWidthValue, fBoundMinX, *pCurMaxX);
          *pCurMaxX = ImClamp(*pCurMaxX - fDeltaWidthValue, *pCurMinX, fBoundMaxX);
        }

        bModified = true;
      } else {
        //if ((ImGui::IsMouseDown(ImGuiMouseButton_Left) || ImGui::IsMouseDown(ImGuiMouseButton_Right)) &&
        //	ImGui::IsMouseHoveringRect(oHeightHandle.Min - ImVec2(fCursorOff, fCursorOff) - vSecurity, oHeightHandle.Max + ImVec2(fCursorOff, fCursorOff) + vSecurity))
        pressed = ImGui::ButtonBehavior(vDragHandleHeight, ImGui::GetID("##Zone"), &hovered, &held);
        if (hovered && held) {
          constexpr float fSpeedHandleHeight = 0.125f;
          float fDeltaHeight = oHeightHandle.GetCenter().y - ImGui::GetMousePos().y;
          // Apply Soft-Threshold
          //fDeltaHeight = fSpeedHandleHeight*Sign(fDeltaHeight)*std::max(std::abs(fDeltaHeight) - 0.5f*fCursorOff, 0.0f);
          fDeltaHeight =
              fSpeedHandleHeight * ImClamp(fDeltaHeight, -0.5f * oRect.GetHeight(), 0.5f * oRect.GetHeight());

          float fDeltaHeightValue = Rescale(fDeltaHeight, -0.5f * oRect.GetHeight(), 0.5f * oRect.GetHeight(),
                                            -0.5f * (fBoundMaxY - fBoundMinY), 0.5f * (fBoundMaxY - fBoundMinY));

          if (ImGui::IsMouseDown(ImGuiMouseButton_Right)) {
            *pCurMinY = ImClamp(*pCurMinY + fArbitrarySpeedScaleBar * fDeltaHeightValue, fBoundMinY, *pCurMaxY);
            *pCurMaxY = ImClamp(*pCurMaxY - fArbitrarySpeedScaleBar * fDeltaHeightValue, *pCurMinY, fBoundMaxY);
          } else {
            if (*pCurMinY <= fBoundMinY && fDeltaHeightValue > 0.0f) {
              fDeltaHeightValue = 0.0f;
            } else if (*pCurMaxY >= fBoundMaxY && fDeltaHeightValue < 0.0f) {
              fDeltaHeightValue = 0.0f;
            }

            *pCurMinY = ImClamp(*pCurMinY - fDeltaHeightValue, fBoundMinY, *pCurMaxY);
            *pCurMaxY = ImClamp(*pCurMaxY - fDeltaHeightValue, *pCurMinY, fBoundMaxY);
          }

          bModified = true;
        } else {
          //if (ImGui::IsMouseHoveringRect(oRegionRect.Min, oRegionRect.Max) && !oRegionRect.IsInverted())
          pressed = ImGui::ButtonBehavior(vDragRect, ImGui::GetID("##Zone"), &hovered, &held);
          if (hovered && held) {
            // Top Left
            pDrawList->AddLine(oDragZone.Min, oDragZone.Min + ImVec2(oRegionRect.GetWidth() * 0.2f, 0.0f), uFrameCol,
                               1.0f);
            pDrawList->AddLine(oDragZone.Min, oDragZone.Min + ImVec2(0.0f, oRegionRect.GetHeight() * 0.2f), uFrameCol,
                               1.0f);
            // Bottom Right
            pDrawList->AddLine(oDragZone.Max, oDragZone.Max - ImVec2(oRegionRect.GetWidth() * 0.2f, 0.0f), uFrameCol,
                               1.0f);
            pDrawList->AddLine(oDragZone.Max, oDragZone.Max - ImVec2(0.0f, oRegionRect.GetHeight() * 0.2f), uFrameCol,
                               1.0f);

            if (ImGui::IsMouseDown(ImGuiMouseButton_Left) && ImGui::IsMouseHoveringRect(oDragZone.Min, oDragZone.Max)) {
              ImVec2 vDragDelta = ImGui::GetMousePos() - oDragZone.GetCenter();

              if (*pCurMinX <= fBoundMinX && vDragDelta.x < 0.0f) {
                vDragDelta.x = 0.0f;
              } else if (*pCurMaxX >= fBoundMaxX && vDragDelta.x > 0.0f) {
                vDragDelta.x = 0.0f;
              }

              if (*pCurMinY <= fBoundMinY && vDragDelta.y < 0.0f) {
                vDragDelta.y = 0.0f;
              } else if (*pCurMaxY >= fBoundMaxY && vDragDelta.y > 0.0f) {
                vDragDelta.y = 0.0f;
              }

              float fLocalDeltaX = Rescale(vDragDelta.x, -0.5f * oRect.GetWidth(), 0.5f * oRect.GetWidth(),
                                           -0.5f * (fBoundMaxX - fBoundMinX), 0.5f * (fBoundMaxX - fBoundMinX));
              float fLocalDeltaY = Rescale(vDragDelta.y, -0.5f * oRect.GetHeight(), 0.5f * oRect.GetHeight(),
                                           -0.5f * (fBoundMaxY - fBoundMinY), 0.5f * (fBoundMaxY - fBoundMinY));

              *pCurMinX = ImClamp(*pCurMinX + fLocalDeltaX, fBoundMinX, *pCurMaxX);
              *pCurMaxX = ImClamp(*pCurMaxX + fLocalDeltaX, *pCurMinX, fBoundMaxX);

              *pCurMinY = ImClamp(*pCurMinY + fLocalDeltaY, fBoundMinY, *pCurMaxY);
              *pCurMaxY = ImClamp(*pCurMaxY + fLocalDeltaY, *pCurMinY, fBoundMaxY);
            }
          }
        }
      }
    }
  }

  char pBufferMinX[16];
  char pBufferMaxX[16];
  char pBufferMinY[16];
  char pBufferMaxY[16];
  ImFormatString(pBufferMinX, IM_ARRAYSIZE(pBufferMinX), "%.5f", *(float const *) pCurMinX);
  ImFormatString(pBufferMaxX, IM_ARRAYSIZE(pBufferMaxX), "%.5f", *(float const *) pCurMaxX);
  ImFormatString(pBufferMinY, IM_ARRAYSIZE(pBufferMinY), "%.5f", *(float const *) pCurMinY);
  ImFormatString(pBufferMaxY, IM_ARRAYSIZE(pBufferMaxY), "%.5f", *(float const *) pCurMaxY);

  ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

  ImGui::SetWindowFontScale(0.75f);

  ImVec2 const vMinXSize = ImGui::CalcTextSize(pBufferMinX);
  ImVec2 const vMaxXSize = ImGui::CalcTextSize(pBufferMaxX);
  ImVec2 const vMinYSize = ImGui::CalcTextSize(pBufferMinY);
  ImVec2 const vMaxYSize = ImGui::CalcTextSize(pBufferMaxY);

  pDrawList->AddText(ImVec2(vMinCursorPos.x - 0.5f * vMinXSize.x, oRect.Max.y + fCursorOff), uTextCol, pBufferMinX);
  pDrawList->AddText(ImVec2(vMaxCursorPos.x - 0.5f * vMaxXSize.x, oRect.Max.y + fCursorOff), uTextCol, pBufferMaxX);

  pDrawList->AddText(ImVec2(oRect.Max.x + fCursorOff, vMinCursorPos.y - 0.5f * vMinYSize.y), uTextCol, pBufferMinY);
  pDrawList->AddText(ImVec2(oRect.Max.x + fCursorOff, vMaxCursorPos.y - 0.5f * vMaxYSize.y), uTextCol, pBufferMaxY);

  ImGui::SetWindowFontScale(1.0f);

  if (!oRegionRect.IsInverted()) {
    pDrawList->AddLine(vMinCursorPos + ImVec2(fCursorOff, 0.0f), vMinCursorPos + ImVec2(2.0f * fCursorOff, 0.0f),
                       uOrange, fLineThickness);
    pDrawList->AddLine(vMinCursorPos + ImVec2(0.0f, fCursorOff), vMinCursorPos + ImVec2(0.0f, 2.0f * fCursorOff),
                       uOrange, fLineThickness);

    pDrawList->AddLine(vMaxCursorPos - ImVec2(fCursorOff, 0.0f), vMaxCursorPos - ImVec2(2.0f * fCursorOff, 0.0f),
                       uOrange, fLineThickness);
    pDrawList->AddLine(vMaxCursorPos - ImVec2(0.0f, fCursorOff), vMaxCursorPos - ImVec2(0.0f, 2.0f * fCursorOff),
                       uOrange, fLineThickness);
  }

  // Cross Center
  pDrawList->AddLine(oDragZone.GetCenter() - ImVec2(fCursorOff, 0.0f), oDragZone.GetCenter() + ImVec2(fCursorOff, 0.0f),
                     uFrameCol, 1.0f);
  pDrawList->AddLine(oDragZone.GetCenter() - ImVec2(0.0f, fCursorOff), oDragZone.GetCenter() + ImVec2(0.0f, fCursorOff),
                     uFrameCol, 1.0f);
  //////////////////////////////////////////////////////////////////////////
  // Top Left
  pDrawList->AddLine(oRect.Min, ImVec2(vMinCursorPos.x, oRect.Min.y), uOrange, fLineThickness);
  pDrawList->AddLine(oRect.Min, ImVec2(oRect.Min.x, vMinCursorPos.y), uOrange, fLineThickness);
  // Bottom Left
  pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(vMinCursorPos.x - fCursorOff, oRect.Max.y), uOrange,
                     fLineThickness);
  pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(oRect.Min.x, vMaxCursorPos.y), uOrange, fLineThickness);
  //
  pDrawList->AddLine(ImVec2(vMinCursorPos.x + fCursorOff, oRect.Max.y),
                     ImVec2(vMaxCursorPos.x - fCursorOff, oRect.Max.y), uOrange, fLineThickness);
  pDrawList->AddLine(ImVec2(vMaxCursorPos.x + fCursorOff, oRect.Max.y), ImVec2(oRect.Max.x, oRect.Max.y), uOrange,
                     fLineThickness);
  // Right
  pDrawList->AddLine(oRect.Max, ImVec2(oRect.Max.x, vMaxCursorPos.y + fCursorOff), uOrange, fLineThickness);
  pDrawList->AddLine(ImVec2(oRect.Max.x, vMaxCursorPos.y - fCursorOff),
                     ImVec2(oRect.Max.x, vMinCursorPos.y + fCursorOff), uOrange, fLineThickness);
  pDrawList->AddLine(ImVec2(oRect.Max.x, vMinCursorPos.y - fCursorOff), ImVec2(oRect.Max.x, oRect.Min.y), uOrange,
                     fLineThickness);
  // Top Right
  pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Min.y), ImVec2(vMaxCursorPos.x, oRect.Min.y), uOrange, fLineThickness);
  // Top Handle
  pDrawList->AddLine(ImVec2(vMinCursorPos.x, oRect.Min.y - fCursorOff),
                     ImVec2(vMinCursorPos.x, oRect.Min.y + fCursorOff), uBlue, fLineThickness);
  pDrawList->AddLine(ImVec2(vMaxCursorPos.x, oRect.Min.y - fCursorOff),
                     ImVec2(vMaxCursorPos.x, oRect.Min.y + fCursorOff), uBlue, fLineThickness);
  pDrawList->AddRectFilled(oWidthHandle.Min, oWidthHandle.Max, uBlue);
  // Left Handle
  pDrawList->AddLine(ImVec2(oRect.Min.x - fCursorOff, vMinCursorPos.y),
                     ImVec2(oRect.Min.x + fCursorOff, vMinCursorPos.y), uBlue, fLineThickness);
  pDrawList->AddLine(ImVec2(oRect.Min.x - fCursorOff, vMaxCursorPos.y),
                     ImVec2(oRect.Min.x + fCursorOff, vMaxCursorPos.y), uBlue, fLineThickness);
  pDrawList->AddRectFilled(oHeightHandle.Min, oHeightHandle.Max, uBlue);
  // Dots
  pDrawList->AddCircleFilled(ImVec2(oRect.Max.x, vMinCursorPos.y), 2.0f, uBlue, 3);
  pDrawList->AddCircleFilled(ImVec2(oRect.Max.x, vMaxCursorPos.y), 2.0f, uBlue, 3);
  pDrawList->AddCircleFilled(ImVec2(vMinCursorPos.x, oRect.Max.y), 2.0f, uBlue, 3);
  pDrawList->AddCircleFilled(ImVec2(vMaxCursorPos.x, oRect.Max.y), 2.0f, uBlue, 3);
  //////////////////////////////////////////////////////////////////////////

  ImGui::PopID();

  //ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vSize);

  ImGui::Text("Min x: %f", fCurMinX);
  ImGui::Text("Min y: %f", fCurMinY);
  ImGui::Text("Max x: %f", fCurMaxX);
  ImGui::Text("Max y: %f", fCurMaxY);

  ImGui::Dummy(vHeightOffset);

  return bModified;
}

bool RangeSelect2D(char const *pLabel, float *pCurMinX, float *pCurMinY, float *pCurMaxX, float *pCurMaxY,
                   float const fBoundMinX, float const fBoundMinY, float const fBoundMaxX, float const fBoundMaxY,
                   float const fScale /*= 1.0f*/) {
  //EMV_ASSERT(fBoundMinX < fBoundMaxX);
  //EMV_ASSERT(fBoundMinY < fBoundMaxY);

  float &fCurMinX = *pCurMinX;
  float &fCurMinY = *pCurMinY;
  float &fCurMaxX = *pCurMaxX;
  float &fCurMaxY = *pCurMaxY;

  //EMV_ASSERT(fCurMinX < fCurMaxX);
  //EMV_ASSERT(fCurMinY < fCurMaxY);

  float const fDeltaBoundX = fBoundMaxX - fBoundMinX;
  float const fDeltaBoundY = fBoundMaxY - fBoundMinY;

  float const fDeltaX = fCurMaxX - fCurMinX;
  float const fDeltaY = fCurMaxY - fCurMinY;

  float const fScaleX = fDeltaX / fDeltaBoundX;
  float const fScaleY = fDeltaY / fDeltaBoundY;
  float const fScaleMinX = Rescale01(fCurMinX, fBoundMinX, fBoundMaxX);
  float const fScaleMinY = Rescale01(fCurMinY, fBoundMinY, fBoundMaxY);
  float const fScaleMaxX = Rescale01(fCurMaxX, fBoundMinX, fBoundMaxX);
  float const fScaleMaxY = Rescale01(fCurMaxY, fBoundMinY, fBoundMaxY);

  ImGuiID const iID = ImGui::GetID(pLabel);

  ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;

  float const vSizeFull = (ImGui::GetContentRegionAvail().x - vSizeSubstract.x) * fScale;
  ImVec2 const vSize(vSizeFull, vSizeFull);

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos + vHeightOffset, vPos + vSize + vHeightOffset);

  constexpr float fCursorOff = 10.0f;
  [[maybe_unused]] float const fXLimit = fCursorOff / oRect.GetWidth();
  [[maybe_unused]] float const fYLimit = fCursorOff / oRect.GetHeight();

  ImVec2 const vCursorPos((oRect.Max.x - oRect.Min.x) * fScaleX + oRect.Min.x,
                          (oRect.Max.y - oRect.Min.y) * fScaleY + oRect.Min.y);

  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vHeightOffset);

  //ImGui::Text(pLabel);

  ImGui::PushID(iID);
  ImU32 const uFrameCol = ImGui::GetColorU32(ImGuiCol_FrameBg);
  ImU32 const uFrameZoneCol = ImGui::GetColorU32(ImGuiCol_FrameBgActive);

  [[maybe_unused]] ImVec2 const vOriginPos = ImGui::GetCursorScreenPos();
  ImGui::RenderFrame(oRect.Min, oRect.Max, uFrameCol, false, 0.0f);
  bool bModified = false;
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImDrawList *pDrawList = ImGui::GetWindowDrawList();

  ImVec4 const vBlue(70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f);// TODO: choose from style
  [[maybe_unused]] ImVec4 const vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f,
                                        1.0f);// TODO: choose from style

  ImS32 const uBlue = ImGui::GetColorU32(vBlue);
  ImS32 const uOrange = ImGui::GetColorU32(vOrange);

  [[maybe_unused]] constexpr float fBorderThickness = 2.0f;
  constexpr float fLineThickness = 3.0f;
  constexpr float fHandleRadius = 7.0f;
  [[maybe_unused]] constexpr float fHandleOffsetCoef = 2.0f;

  float const fRegMinX = ImLerp(oRect.Min.x, oRect.Max.x, fScaleMinX);
  float const fRegMinY = ImLerp(oRect.Min.y, oRect.Max.y, fScaleMinY);
  float const fRegMaxX = ImLerp(oRect.Min.x, oRect.Max.x, fScaleMaxX);
  float const fRegMaxY = ImLerp(oRect.Min.y, oRect.Max.y, fScaleMaxY);

  ImRect oRegionRect(fRegMinX, fRegMinY, fRegMaxX, fRegMaxY);

  ImVec2 vMinCursorPos(fRegMinX, fRegMinY);
  ImVec2 vMaxCursorPos(fRegMaxX, fRegMaxY);

  float const fRegWidth = oRegionRect.GetWidth();
  ImRect oWidthHandle(ImVec2(vMinCursorPos.x + 0.25f * fRegWidth, oRect.Min.y - 0.5f * fCursorOff),
                      ImVec2(vMaxCursorPos.x - 0.25f * fRegWidth, oRect.Min.y + 0.5f * fCursorOff));
  float const fRegHeight = oRegionRect.GetHeight();
  ImRect oHeightHandle(ImVec2(oRect.Min.x - 0.5f * fCursorOff, vMinCursorPos.y + 0.25f * fRegHeight),
                       ImVec2(oRect.Min.x + 0.5f * fCursorOff, vMaxCursorPos.y - 0.25f * fRegHeight));

  //pDrawList->AddRect(oRect.Min, oRect.Max, uBlue, 0.0f, 0, fBorderThickness);
  //pDrawList->AddRect(oRegionRect.Min, oRegionRect.Max, uOrange, 0.0f, 0, fLineThickness);

  ImGui::RenderFrame(oRegionRect.Min, oRegionRect.Max, uFrameZoneCol, false, 0.0f);

  pDrawList->AddNgonFilled(vMinCursorPos, 5.0f, uBlue, 4);
  pDrawList->AddNgonFilled(vMaxCursorPos, 5.0f, uBlue, 4);

  ImRect oDragZone(oRegionRect.Min + ImVec2(fCursorOff, fCursorOff) + vSecurity,
                   oRegionRect.Max - ImVec2(fCursorOff, fCursorOff) - vSecurity);
  //if (oDragZone.IsInverted())
  //{
  //	oDragZone.Min = ImVec2();
  //	oDragZone.Max = ImVec2();
  //}

  //if (ImGui::IsMouseDown(ImGuiMouseButton_Left) &&
  //	ImGui::IsMouseHoveringRect(vMinCursorPos - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vMinCursorPos + ImVec2(fHandleRadius, fHandleRadius) + vSecurity))

  ImRect vDragBBMin(vMinCursorPos - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                    vMinCursorPos + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  ImRect vDragBBMax(vMaxCursorPos - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                    vMaxCursorPos + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  ImRect vDragHandleMin(oWidthHandle.Min - ImVec2(fCursorOff, fCursorOff) - vSecurity,
                        oWidthHandle.Max + ImVec2(fCursorOff, fCursorOff) + vSecurity);
  ImRect vDragHandleHeight(oHeightHandle.Min - ImVec2(fCursorOff, fCursorOff) - vSecurity,
                           oHeightHandle.Max + ImVec2(fCursorOff, fCursorOff) + vSecurity);
  ImRect vDragRect(oRegionRect.Min, oRegionRect.Max);

  // TODO:
  float const fArbitrarySpeedScaleBar = 0.0125f;

  bool hovered;
  bool held;
  [[maybe_unused]] bool pressed = ImGui::ButtonBehavior(vDragBBMin, ImGui::GetID("##Zone"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vLocalCursorPos = ImGui::GetMousePos();

    ImVec2 newVal = Rescalev(vLocalCursorPos, ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(oRect.Max.x, oRect.Max.y),
                             ImVec2(fBoundMinX, fBoundMinY), ImVec2(fBoundMaxX, fBoundMaxY));

    newVal.x = ImClamp(newVal.x, fBoundMinX, *pCurMaxX);
    newVal.y = ImClamp(newVal.y, fBoundMinY, *pCurMaxY);

    *pCurMinX = newVal.x;
    *pCurMinY = newVal.y;

    bModified = true;
  } else {
    //if (ImGui::IsMouseDown(ImGuiMouseButton_Left) &&
    //	ImGui::IsMouseHoveringRect(vMaxCursorPos - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vMaxCursorPos + ImVec2(fHandleRadius, fHandleRadius) + vSecurity))
    pressed = ImGui::ButtonBehavior(vDragBBMax, ImGui::GetID("##Zone"), &hovered, &held);
    if (hovered && held) {
      ImVec2 const vLocalCursorPos = ImGui::GetMousePos();

      ImVec2 newVal = Rescalev(vLocalCursorPos, ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(oRect.Max.x, oRect.Max.y),
                               ImVec2(fBoundMinX, fBoundMinY), ImVec2(fBoundMaxX, fBoundMaxY));

      newVal.x = ImClamp(newVal.x, *pCurMinX, fBoundMaxX);
      newVal.y = ImClamp(newVal.y, *pCurMinY, fBoundMaxY);

      *pCurMaxX = newVal.x;
      *pCurMaxY = newVal.y;

      bModified = true;
    } else {
      //if ((ImGui::IsMouseDown(ImGuiMouseButton_Left) || ImGui::IsMouseDown(ImGuiMouseButton_Right)) &&
      //	ImGui::IsMouseHoveringRect(oWidthHandle.Min - ImVec2(fCursorOff, fCursorOff) - vSecurity, oWidthHandle.Max + ImVec2(fCursorOff, fCursorOff) + vSecurity))
      pressed = ImGui::ButtonBehavior(vDragHandleMin, ImGui::GetID("##Zone"), &hovered, &held);
      if (hovered && held) {
        constexpr float fSpeedHandleWidth = 0.125f;
        float fDeltaWidth = oWidthHandle.GetCenter().x - ImGui::GetMousePos().x;
        // Apply Soft-Threshold
        //fDeltaWidth = fSpeedHandleWidth*Sign(fDeltaWidth)*std::max(std::abs(fDeltaWidth) - 0.5f*fCursorOff, 0.0f);

        fDeltaWidth = fSpeedHandleWidth * ImClamp(fDeltaWidth, -0.5f * oRect.GetWidth(), 0.5f * oRect.GetWidth());

        float fDeltaWidthValue = Rescale(fDeltaWidth, -0.5f * oRect.GetWidth(), 0.5f * oRect.GetWidth(),
                                         -0.5f * (fBoundMaxX - fBoundMinX), 0.5f * (fBoundMaxX - fBoundMinX));

        if (ImGui::IsMouseDown(ImGuiMouseButton_Right)) {
          *pCurMinX = ImClamp(*pCurMinX + fArbitrarySpeedScaleBar * fDeltaWidthValue, fBoundMinX, *pCurMaxX);
          *pCurMaxX = ImClamp(*pCurMaxX - fArbitrarySpeedScaleBar * fDeltaWidthValue, *pCurMinX, fBoundMaxX);
        } else {
          if (*pCurMinX <= fBoundMinX && fDeltaWidthValue > 0.0f) {
            fDeltaWidthValue = 0.0f;
          } else if (*pCurMaxX >= fBoundMaxX && fDeltaWidthValue < 0.0f) {
            fDeltaWidthValue = 0.0f;
          }

          *pCurMinX = ImClamp(*pCurMinX - fDeltaWidthValue, fBoundMinX, *pCurMaxX);
          *pCurMaxX = ImClamp(*pCurMaxX - fDeltaWidthValue, *pCurMinX, fBoundMaxX);
        }

        bModified = true;
      } else {
        //if ((ImGui::IsMouseDown(ImGuiMouseButton_Left) || ImGui::IsMouseDown(ImGuiMouseButton_Right)) &&
        //	ImGui::IsMouseHoveringRect(oHeightHandle.Min - ImVec2(fCursorOff, fCursorOff) - vSecurity, oHeightHandle.Max + ImVec2(fCursorOff, fCursorOff) + vSecurity))
        pressed = ImGui::ButtonBehavior(vDragHandleHeight, ImGui::GetID("##Zone"), &hovered, &held);
        if (hovered && held) {
          constexpr float fSpeedHandleHeight = 0.125f;
          float fDeltaHeight = oHeightHandle.GetCenter().y - ImGui::GetMousePos().y;
          // Apply Soft-Threshold
          //fDeltaHeight = fSpeedHandleHeight*Sign(fDeltaHeight)*std::max(std::abs(fDeltaHeight) - 0.5f*fCursorOff, 0.0f);
          fDeltaHeight =
              fSpeedHandleHeight * ImClamp(fDeltaHeight, -0.5f * oRect.GetHeight(), 0.5f * oRect.GetHeight());

          float fDeltaHeightValue = Rescale(fDeltaHeight, -0.5f * oRect.GetHeight(), 0.5f * oRect.GetHeight(),
                                            -0.5f * (fBoundMaxY - fBoundMinY), 0.5f * (fBoundMaxY - fBoundMinY));

          if (ImGui::IsMouseDown(ImGuiMouseButton_Right)) {
            *pCurMinY = ImClamp(*pCurMinY + fArbitrarySpeedScaleBar * fDeltaHeightValue, fBoundMinY, *pCurMaxY);
            *pCurMaxY = ImClamp(*pCurMaxY - fArbitrarySpeedScaleBar * fDeltaHeightValue, *pCurMinY, fBoundMaxY);
          } else {
            if (*pCurMinY <= fBoundMinY && fDeltaHeightValue > 0.0f) {
              fDeltaHeightValue = 0.0f;
            } else if (*pCurMaxY >= fBoundMaxY && fDeltaHeightValue < 0.0f) {
              fDeltaHeightValue = 0.0f;
            }

            *pCurMinY = ImClamp(*pCurMinY - fDeltaHeightValue, fBoundMinY, *pCurMaxY);
            *pCurMaxY = ImClamp(*pCurMaxY - fDeltaHeightValue, *pCurMinY, fBoundMaxY);
          }

          bModified = true;
        } else {
          //if (ImGui::IsMouseHoveringRect(oRegionRect.Min, oRegionRect.Max) && !oRegionRect.IsInverted())
          pressed = ImGui::ButtonBehavior(vDragRect, ImGui::GetID("##Zone"), &hovered, &held);
          if (hovered && held) {
            // Top Left
            pDrawList->AddLine(oDragZone.Min, oDragZone.Min + ImVec2(oRegionRect.GetWidth() * 0.2f, 0.0f), uFrameCol,
                               1.0f);
            pDrawList->AddLine(oDragZone.Min, oDragZone.Min + ImVec2(0.0f, oRegionRect.GetHeight() * 0.2f), uFrameCol,
                               1.0f);
            // Bottom Right
            pDrawList->AddLine(oDragZone.Max, oDragZone.Max - ImVec2(oRegionRect.GetWidth() * 0.2f, 0.0f), uFrameCol,
                               1.0f);
            pDrawList->AddLine(oDragZone.Max, oDragZone.Max - ImVec2(0.0f, oRegionRect.GetHeight() * 0.2f), uFrameCol,
                               1.0f);

            if (ImGui::IsMouseDown(ImGuiMouseButton_Left) && ImGui::IsMouseHoveringRect(oDragZone.Min, oDragZone.Max)) {
              ImVec2 vDragDelta = ImGui::GetMousePos() - oDragZone.GetCenter();

              if (*pCurMinX <= fBoundMinX && vDragDelta.x < 0.0f) {
                vDragDelta.x = 0.0f;
              } else if (*pCurMaxX >= fBoundMaxX && vDragDelta.x > 0.0f) {
                vDragDelta.x = 0.0f;
              }

              if (*pCurMinY <= fBoundMinY && vDragDelta.y < 0.0f) {
                vDragDelta.y = 0.0f;
              } else if (*pCurMaxY >= fBoundMaxY && vDragDelta.y > 0.0f) {
                vDragDelta.y = 0.0f;
              }

              float fLocalDeltaX = Rescale(vDragDelta.x, -0.5f * oRect.GetWidth(), 0.5f * oRect.GetWidth(),
                                           -0.5f * (fBoundMaxX - fBoundMinX), 0.5f * (fBoundMaxX - fBoundMinX));
              float fLocalDeltaY = Rescale(vDragDelta.y, -0.5f * oRect.GetHeight(), 0.5f * oRect.GetHeight(),
                                           -0.5f * (fBoundMaxY - fBoundMinY), 0.5f * (fBoundMaxY - fBoundMinY));

              *pCurMinX = ImClamp(*pCurMinX + fLocalDeltaX, fBoundMinX, *pCurMaxX);
              *pCurMaxX = ImClamp(*pCurMaxX + fLocalDeltaX, *pCurMinX, fBoundMaxX);

              *pCurMinY = ImClamp(*pCurMinY + fLocalDeltaY, fBoundMinY, *pCurMaxY);
              *pCurMaxY = ImClamp(*pCurMaxY + fLocalDeltaY, *pCurMinY, fBoundMaxY);
            }
          }
        }
      }
    }
  }

  char pBufferMinX[16];
  char pBufferMaxX[16];
  char pBufferMinY[16];
  char pBufferMaxY[16];
  ImFormatString(pBufferMinX, IM_ARRAYSIZE(pBufferMinX), "%.5f", *(float const *) pCurMinX);
  ImFormatString(pBufferMaxX, IM_ARRAYSIZE(pBufferMaxX), "%.5f", *(float const *) pCurMaxX);
  ImFormatString(pBufferMinY, IM_ARRAYSIZE(pBufferMinY), "%.5f", *(float const *) pCurMinY);
  ImFormatString(pBufferMaxY, IM_ARRAYSIZE(pBufferMaxY), "%.5f", *(float const *) pCurMaxY);

  ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

  ImGui::SetWindowFontScale(0.75f);

  ImVec2 const vMinXSize = ImGui::CalcTextSize(pBufferMinX);
  ImVec2 const vMaxXSize = ImGui::CalcTextSize(pBufferMaxX);
  ImVec2 const vMinYSize = ImGui::CalcTextSize(pBufferMinY);
  ImVec2 const vMaxYSize = ImGui::CalcTextSize(pBufferMaxY);

  pDrawList->AddText(ImVec2(vMinCursorPos.x - 0.5f * vMinXSize.x, oRect.Max.y + fCursorOff), uTextCol, pBufferMinX);
  pDrawList->AddText(ImVec2(vMaxCursorPos.x - 0.5f * vMaxXSize.x, oRect.Max.y + fCursorOff), uTextCol, pBufferMaxX);

  pDrawList->AddText(ImVec2(oRect.Max.x + fCursorOff, vMinCursorPos.y - 0.5f * vMinYSize.y), uTextCol, pBufferMinY);
  pDrawList->AddText(ImVec2(oRect.Max.x + fCursorOff, vMaxCursorPos.y - 0.5f * vMaxYSize.y), uTextCol, pBufferMaxY);

  ImGui::SetWindowFontScale(1.0f);

  if (!oRegionRect.IsInverted()) {
    pDrawList->AddLine(vMinCursorPos + ImVec2(fCursorOff, 0.0f), vMinCursorPos + ImVec2(2.0f * fCursorOff, 0.0f),
                       uOrange, fLineThickness);
    pDrawList->AddLine(vMinCursorPos + ImVec2(0.0f, fCursorOff), vMinCursorPos + ImVec2(0.0f, 2.0f * fCursorOff),
                       uOrange, fLineThickness);

    pDrawList->AddLine(vMaxCursorPos - ImVec2(fCursorOff, 0.0f), vMaxCursorPos - ImVec2(2.0f * fCursorOff, 0.0f),
                       uOrange, fLineThickness);
    pDrawList->AddLine(vMaxCursorPos - ImVec2(0.0f, fCursorOff), vMaxCursorPos - ImVec2(0.0f, 2.0f * fCursorOff),
                       uOrange, fLineThickness);
  }

  // Cross Center
  pDrawList->AddLine(oDragZone.GetCenter() - ImVec2(fCursorOff, 0.0f), oDragZone.GetCenter() + ImVec2(fCursorOff, 0.0f),
                     uFrameCol, 1.0f);
  pDrawList->AddLine(oDragZone.GetCenter() - ImVec2(0.0f, fCursorOff), oDragZone.GetCenter() + ImVec2(0.0f, fCursorOff),
                     uFrameCol, 1.0f);
  //////////////////////////////////////////////////////////////////////////
  // Top Left
  pDrawList->AddLine(oRect.Min, ImVec2(vMinCursorPos.x, oRect.Min.y), uOrange, fLineThickness);
  pDrawList->AddLine(oRect.Min, ImVec2(oRect.Min.x, vMinCursorPos.y), uOrange, fLineThickness);
  // Bottom Left
  pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(vMinCursorPos.x - fCursorOff, oRect.Max.y), uOrange,
                     fLineThickness);
  pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(oRect.Min.x, vMaxCursorPos.y), uOrange, fLineThickness);
  //
  pDrawList->AddLine(ImVec2(vMinCursorPos.x + fCursorOff, oRect.Max.y),
                     ImVec2(vMaxCursorPos.x - fCursorOff, oRect.Max.y), uOrange, fLineThickness);
  pDrawList->AddLine(ImVec2(vMaxCursorPos.x + fCursorOff, oRect.Max.y), ImVec2(oRect.Max.x, oRect.Max.y), uOrange,
                     fLineThickness);
  // Right
  pDrawList->AddLine(oRect.Max, ImVec2(oRect.Max.x, vMaxCursorPos.y + fCursorOff), uOrange, fLineThickness);
  pDrawList->AddLine(ImVec2(oRect.Max.x, vMaxCursorPos.y - fCursorOff),
                     ImVec2(oRect.Max.x, vMinCursorPos.y + fCursorOff), uOrange, fLineThickness);
  pDrawList->AddLine(ImVec2(oRect.Max.x, vMinCursorPos.y - fCursorOff), ImVec2(oRect.Max.x, oRect.Min.y), uOrange,
                     fLineThickness);
  // Top Right
  pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Min.y), ImVec2(vMaxCursorPos.x, oRect.Min.y), uOrange, fLineThickness);
  // Top Handle
  pDrawList->AddLine(ImVec2(vMinCursorPos.x, oRect.Min.y - fCursorOff),
                     ImVec2(vMinCursorPos.x, oRect.Min.y + fCursorOff), uBlue, fLineThickness);
  pDrawList->AddLine(ImVec2(vMaxCursorPos.x, oRect.Min.y - fCursorOff),
                     ImVec2(vMaxCursorPos.x, oRect.Min.y + fCursorOff), uBlue, fLineThickness);
  pDrawList->AddRectFilled(oWidthHandle.Min, oWidthHandle.Max, uBlue);
  // Left Handle
  pDrawList->AddLine(ImVec2(oRect.Min.x - fCursorOff, vMinCursorPos.y),
                     ImVec2(oRect.Min.x + fCursorOff, vMinCursorPos.y), uBlue, fLineThickness);
  pDrawList->AddLine(ImVec2(oRect.Min.x - fCursorOff, vMaxCursorPos.y),
                     ImVec2(oRect.Min.x + fCursorOff, vMaxCursorPos.y), uBlue, fLineThickness);
  pDrawList->AddRectFilled(oHeightHandle.Min, oHeightHandle.Max, uBlue);
  // Dots
  pDrawList->AddCircleFilled(ImVec2(oRect.Max.x, vMinCursorPos.y), 2.0f, uBlue, 3);
  pDrawList->AddCircleFilled(ImVec2(oRect.Max.x, vMaxCursorPos.y), 2.0f, uBlue, 3);
  pDrawList->AddCircleFilled(ImVec2(vMinCursorPos.x, oRect.Max.y), 2.0f, uBlue, 3);
  pDrawList->AddCircleFilled(ImVec2(vMaxCursorPos.x, oRect.Max.y), 2.0f, uBlue, 3);
  //////////////////////////////////////////////////////////////////////////

  ImGui::PopID();

  //ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vSize);

  ImGui::Text("Min x: %f", fCurMinX);
  ImGui::Text("Min y: %f", fCurMinY);
  ImGui::Text("Max x: %f", fCurMaxX);
  ImGui::Text("Max y: %f", fCurMaxY);

  ImGui::Dummy(vHeightOffset);

  return bModified;
}

bool RangeSelectVec2(const char *pLabel, ImVec2 *pCurMin, ImVec2 *pCurMax, ImVec2 const vBoundMin,
                     ImVec2 const vBoundMax, float const fScale /*= 1.0f*/) {
  return RangeSelect2D(pLabel, &pCurMin->x, &pCurMin->y, &pCurMax->x, &pCurMax->y, vBoundMin.x, vBoundMin.y,
                       vBoundMax.x, vBoundMax.y, fScale);
}

bool Slider2DScalar(char const *pLabel, ImGuiDataType data_type, void *p_valueX, void *p_valueY, void *p_minX,
                    void *p_maxX, void *p_minY, void *p_maxY, ImVec2 size) {
  assert(ScalarToFloat(data_type, (ImU64 *) p_minX) < ScalarToFloat(data_type, (ImU64 *) p_maxX));
  assert(ScalarToFloat(data_type, (ImU64 *) p_minY) < ScalarToFloat(data_type, (ImU64 *) p_maxY));

  ImGuiWindow *window = ImGui::GetCurrentWindow();
  if (window->SkipItems) return false;

  //ImGuiContext& g = *GImGui;
  //const ImGuiStyle& style = g.Style;
  //const ImGuiID id = window->GetID(pLabel);

  ImGuiID const iID = ImGui::GetID(pLabel);

  if (size.x == 0) {
    ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;
    float const vSizeFull = (ImGui::GetContentRegionAvail().x - vSizeSubstract.x);
    size.x = vSizeFull;
  }
  if (size.y == 0) {
    ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;
    float const vSizeFull = (ImGui::GetContentRegionAvail().x - vSizeSubstract.x);
    size.y = vSizeFull;
  }

  const auto vSize = size;

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos + vHeightOffset, vPos + vSize + vHeightOffset);

  ImGui::Text("%s", pLabel);

  ImGui::PushID(iID);

  ImU32 const uFrameCol = ImGui::GetColorU32(ImGuiCol_FrameBg);

  [[maybe_unused]] ImVec2 const vOriginPos = ImGui::GetCursorScreenPos();
  ImGui::RenderFrame(oRect.Min, oRect.Max, uFrameCol, false, 0.0f);

  ImU64 s_delta_x = SubScalar(data_type, p_maxX, p_minX);
  ImU64 s_delta_y = SubScalar(data_type, p_maxY, p_minY);

  bool bModified = false;
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImRect frame_bb = ImRect(oRect.Min - vSecurity, oRect.Max + vSecurity);
  //ImGui::PushItemFlag(ImGuiItemFlags_NoNav, true);
  bool hovered;
  bool held;
  [[maybe_unused]] bool pressed = ImGui::ButtonBehavior(frame_bb, ImGui::GetID("##Zone"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vCursorPos = ImGui::GetMousePos() - oRect.Min;

    float fValueX = vCursorPos.x / (oRect.Max.x - oRect.Min.x) * ScalarToFloat(data_type, &s_delta_x)
        + ScalarToFloat(data_type, (ImU64 *) p_minX);
    float fValueY = ScalarToFloat(data_type, &s_delta_y)
        - vCursorPos.y / (oRect.Max.y - oRect.Min.y) * ScalarToFloat(data_type, &s_delta_y)
        + ScalarToFloat(data_type, (ImU64 *) p_minY);

    ImU64 s_value_x = FloatToScalar(data_type, fValueX);
    ImU64 s_value_y = FloatToScalar(data_type, fValueY);

    EqualScalar(data_type, (ImU64 *) p_valueX, &s_value_x);
    EqualScalar(data_type, (ImU64 *) p_valueY, &s_value_y);

    bModified = true;
  }
  //ImGui::PopItemFlag();

  ImU64 s_clamped_x = ClampScalar(data_type, p_valueX, p_minX, p_maxX);
  ImU64 s_clamped_y = ClampScalar(data_type, p_valueY, p_minY, p_maxY);
  EqualScalar(data_type, (ImU64 *) p_valueX, &s_clamped_x);
  EqualScalar(data_type, (ImU64 *) p_valueY, &s_clamped_y);

  float const fScaleX = (ScalarToFloat(data_type, (ImU64 *) p_valueX) - ScalarToFloat(data_type, (ImU64 *) p_minX))
      / ScalarToFloat(data_type, &s_delta_x);
  float const fScaleY = 1.0f
      - (ScalarToFloat(data_type, (ImU64 *) p_valueY) - ScalarToFloat(data_type, (ImU64 *) p_minY))
          / ScalarToFloat(data_type, &s_delta_y);

  constexpr float fCursorOff = 10.0f;
  float const fXLimit = fCursorOff / oRect.GetWidth();
  float const fYLimit = fCursorOff / oRect.GetHeight();

  ImVec2 const vCursorPos((oRect.Max.x - oRect.Min.x) * fScaleX + oRect.Min.x,
                          (oRect.Max.y - oRect.Min.y) * fScaleY + oRect.Min.y);

  ImDrawList *pDrawList = ImGui::GetWindowDrawList();

  ImVec4 const vBlue(70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f);// TODO: choose from style
  [[maybe_unused]] ImVec4 const vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f,
                                        1.0f);// TODO: choose from style

  ImS32 const uBlue = ImGui::GetColorU32(vBlue);
  ImS32 const uOrange = ImGui::GetColorU32(vOrange);

  constexpr float fBorderThickness = 2.0f;
  constexpr float fLineThickness = 3.0f;
  constexpr float fHandleRadius = 7.0f;
  constexpr float fHandleOffsetCoef = 2.0f;

  // Cursor
  pDrawList->AddCircleFilled(vCursorPos, 5.0f, uBlue, 16);

  // Vertical Line
  if (fScaleY > 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x, oRect.Min.y + fCursorOff), ImVec2(vCursorPos.x, vCursorPos.y - fCursorOff),
                       uOrange, fLineThickness);
  if (fScaleY < 1.0f - 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x, oRect.Max.y - fCursorOff), ImVec2(vCursorPos.x, vCursorPos.y + fCursorOff),
                       uOrange, fLineThickness);

  // Horizontal Line
  if (fScaleX > 2.0f * fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x + fCursorOff, vCursorPos.y), ImVec2(vCursorPos.x - fCursorOff, vCursorPos.y),
                       uOrange, fLineThickness);
  if (fScaleX < 1.0f - 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x - fCursorOff, vCursorPos.y), ImVec2(vCursorPos.x + fCursorOff, vCursorPos.y),
                       uOrange, fLineThickness);

  std::string formatX = ImGui::DataTypeGetInfo(data_type)->PrintFmt;
  std::string formatY = ImGui::DataTypeGetInfo(data_type)->PrintFmt;

  if (IsPositiveScalar(data_type, (ImU64 *) p_valueX)) { formatX = " " + formatX; }
  if (IsPositiveScalar(data_type, (ImU64 *) p_valueY)) { formatY = " " + formatY; }

  char pBufferX[64];
  char pBufferY[64];
  /*const char* value_buf_end_x = pBufferX + */ ImGui::DataTypeFormatString(pBufferX, IM_ARRAYSIZE(pBufferX), data_type,
                                                                            p_valueX, formatX.c_str());
  /*const char* value_buf_end_y = pBufferX + */ ImGui::DataTypeFormatString(pBufferY, IM_ARRAYSIZE(pBufferY), data_type,
                                                                            p_valueY, formatY.c_str());

  ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

  ImGui::SetWindowFontScale(0.75f);

  ImVec2 const vXSize = ImGui::CalcTextSize(pBufferX);
  ImVec2 const vYSize = ImGui::CalcTextSize(pBufferY);

  ImVec2 const vHandlePosX = ImVec2(vCursorPos.x, oRect.Max.y + vYSize.x * 0.5f);
  ImVec2 const vHandlePosY = ImVec2(oRect.Max.x + fHandleOffsetCoef * fCursorOff + vYSize.x, vCursorPos.y);

  ImRect handle_x_bb = ImRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                              vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  ImRect handle_y_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                              vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  pressed = ImGui::ButtonBehavior(handle_x_bb, ImGui::GetID("##HandleX"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vCursorPosLocal = ImGui::GetMousePos() - oRect.Min;

    //*fValueX = vCursorPos.x / (oRect.Max.x - oRect.Min.x) * fDeltaX + fMinX;
    float fValueX = vCursorPosLocal.x / (oRect.Max.x - oRect.Min.x) * ScalarToFloat(data_type, &s_delta_x)
        + ScalarToFloat(data_type, (ImU64 *) p_minX);
    ImU64 s_value_x = FloatToScalar(data_type, fValueX);
    EqualScalar(data_type, (ImU64 *) p_valueX, &s_value_x);

    bModified = true;
  }
  pressed = ImGui::ButtonBehavior(handle_y_bb, ImGui::GetID("##HandleX"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vCursorPosLocal = ImGui::GetMousePos() - oRect.Min;

    //*fValueY = fDeltaY - vCursorPos.y / (oRect.Max.y - oRect.Min.y) * fDeltaY + fMinY;
    float fValueY = ScalarToFloat(data_type, &s_delta_y)
        - vCursorPosLocal.y / (oRect.Max.y - oRect.Min.y) * ScalarToFloat(data_type, &s_delta_y)
        + ScalarToFloat(data_type, (ImU64 *) p_minY);
    ImU64 s_value_y = FloatToScalar(data_type, fValueY);
    EqualScalar(data_type, (ImU64 *) p_valueY, &s_value_y);

    bModified = true;
  }

  pDrawList->AddText(ImVec2(ImMin(ImMax(vCursorPos.x - vXSize.x * 0.5f, oRect.Min.x), oRect.Min.x + vSize.x - vXSize.x),
                            oRect.Max.y + fCursorOff),
                     uTextCol, pBufferX);
  pDrawList->AddText(
      ImVec2(oRect.Max.x + fCursorOff,
             ImMin(ImMax(vCursorPos.y - vYSize.y * 0.5f, oRect.Min.y), oRect.Min.y + vSize.y - vYSize.y)),
      uTextCol, pBufferY);
  ImGui::SetWindowFontScale(1.0f);

  // Borders::Right
  pDrawList->AddCircleFilled(ImVec2(oRect.Max.x, vCursorPos.y), 2.0f, uOrange, 3);
  // Handle Right::Y
  pDrawList->AddNgonFilled(ImVec2(oRect.Max.x + fHandleOffsetCoef * fCursorOff + vYSize.x, vCursorPos.y), fHandleRadius,
                           uBlue, 4);
  if (fScaleY > fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Min.y), ImVec2(oRect.Max.x, vCursorPos.y - fCursorOff), uBlue,
                       fBorderThickness);
  if (fScaleY < 1.0f - fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Max.y), ImVec2(oRect.Max.x, vCursorPos.y + fCursorOff), uBlue,
                       fBorderThickness);
  // Borders::Top
  pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oRect.Min.y), 2.0f, uOrange, 3);
  if (fScaleX > fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(vCursorPos.x - fCursorOff, oRect.Min.y), uBlue,
                       fBorderThickness);
  if (fScaleX < 1.0f - fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Min.y), ImVec2(vCursorPos.x + fCursorOff, oRect.Min.y), uBlue,
                       fBorderThickness);
  // Borders::Left
  pDrawList->AddCircleFilled(ImVec2(oRect.Min.x, vCursorPos.y), 2.0f, uOrange, 3);
  if (fScaleY > fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(oRect.Min.x, vCursorPos.y - fCursorOff), uBlue,
                       fBorderThickness);
  if (fScaleY < 1.0f - fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(oRect.Min.x, vCursorPos.y + fCursorOff), uBlue,
                       fBorderThickness);
  // Borders::Bottom
  pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oRect.Max.y), 2.0f, uOrange, 3);
  // Handle Bottom::X
  pDrawList->AddNgonFilled(ImVec2(vCursorPos.x, oRect.Max.y + vXSize.y * 2.0f), fHandleRadius, uBlue, 4);
  if (fScaleX > fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(vCursorPos.x - fCursorOff, oRect.Max.y), uBlue,
                       fBorderThickness);
  if (fScaleX < 1.0f - fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Max.y), ImVec2(vCursorPos.x + fCursorOff, oRect.Max.y), uBlue,
                       fBorderThickness);

  ImGui::PopID();

  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vSize);

  return bModified;
}

bool Slider2DScalar(char const *pLabel, ImGuiDataType data_type, void *p_valueX, void *p_valueY, void *p_minX,
                    void *p_maxX, void *p_minY, void *p_maxY, float const fScale /*= 1.0f*/) {
  assert(ScalarToFloat(data_type, (ImU64 *) p_minX) < ScalarToFloat(data_type, (ImU64 *) p_maxX));
  assert(ScalarToFloat(data_type, (ImU64 *) p_minY) < ScalarToFloat(data_type, (ImU64 *) p_maxY));

  ImGuiWindow *window = ImGui::GetCurrentWindow();
  if (window->SkipItems) return false;

  //ImGuiContext& g = *GImGui;
  //const ImGuiStyle& style = g.Style;
  //const ImGuiID id = window->GetID(pLabel);

  ImGuiID const iID = ImGui::GetID(pLabel);

  ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;

  float const vSizeFull = (ImGui::GetContentRegionAvail().x - vSizeSubstract.x) * fScale;
  ImVec2 const vSize(vSizeFull, vSizeFull);

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos + vHeightOffset, vPos + vSize + vHeightOffset);

  ImGui::Text("%s", pLabel);

  ImGui::PushID(iID);

  ImU32 const uFrameCol = ImGui::GetColorU32(ImGuiCol_FrameBg);

  [[maybe_unused]] ImVec2 const vOriginPos = ImGui::GetCursorScreenPos();
  ImGui::RenderFrame(oRect.Min, oRect.Max, uFrameCol, false, 0.0f);

  ImU64 s_delta_x = SubScalar(data_type, p_maxX, p_minX);
  ImU64 s_delta_y = SubScalar(data_type, p_maxY, p_minY);

  bool bModified = false;
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImRect frame_bb = ImRect(oRect.Min - vSecurity, oRect.Max + vSecurity);
  //ImGui::PushItemFlag(ImGuiItemFlags_NoNav, true);
  bool hovered;
  bool held;
  [[maybe_unused]] bool pressed = ImGui::ButtonBehavior(frame_bb, ImGui::GetID("##Zone"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vCursorPos = ImGui::GetMousePos() - oRect.Min;

    float fValueX = vCursorPos.x / (oRect.Max.x - oRect.Min.x) * ScalarToFloat(data_type, &s_delta_x)
        + ScalarToFloat(data_type, (ImU64 *) p_minX);
    float fValueY = ScalarToFloat(data_type, &s_delta_y)
        - vCursorPos.y / (oRect.Max.y - oRect.Min.y) * ScalarToFloat(data_type, &s_delta_y)
        + ScalarToFloat(data_type, (ImU64 *) p_minY);

    ImU64 s_value_x = FloatToScalar(data_type, fValueX);
    ImU64 s_value_y = FloatToScalar(data_type, fValueY);

    EqualScalar(data_type, (ImU64 *) p_valueX, &s_value_x);
    EqualScalar(data_type, (ImU64 *) p_valueY, &s_value_y);

    bModified = true;
  }
  //ImGui::PopItemFlag();

  ImU64 s_clamped_x = ClampScalar(data_type, p_valueX, p_minX, p_maxX);
  ImU64 s_clamped_y = ClampScalar(data_type, p_valueY, p_minY, p_maxY);
  EqualScalar(data_type, (ImU64 *) p_valueX, &s_clamped_x);
  EqualScalar(data_type, (ImU64 *) p_valueY, &s_clamped_y);

  float const fScaleX = (ScalarToFloat(data_type, (ImU64 *) p_valueX) - ScalarToFloat(data_type, (ImU64 *) p_minX))
      / ScalarToFloat(data_type, &s_delta_x);
  float const fScaleY = 1.0f
      - (ScalarToFloat(data_type, (ImU64 *) p_valueY) - ScalarToFloat(data_type, (ImU64 *) p_minY))
          / ScalarToFloat(data_type, &s_delta_y);

  constexpr float fCursorOff = 10.0f;
  float const fXLimit = fCursorOff / oRect.GetWidth();
  float const fYLimit = fCursorOff / oRect.GetHeight();

  ImVec2 const vCursorPos((oRect.Max.x - oRect.Min.x) * fScaleX + oRect.Min.x,
                          (oRect.Max.y - oRect.Min.y) * fScaleY + oRect.Min.y);

  ImDrawList *pDrawList = ImGui::GetWindowDrawList();

  ImVec4 const vBlue(70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f);// TODO: choose from style
  [[maybe_unused]] ImVec4 const vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f,
                                        1.0f);// TODO: choose from style

  ImS32 const uBlue = ImGui::GetColorU32(vBlue);
  ImS32 const uOrange = ImGui::GetColorU32(vOrange);

  constexpr float fBorderThickness = 2.0f;
  constexpr float fLineThickness = 3.0f;
  constexpr float fHandleRadius = 7.0f;
  constexpr float fHandleOffsetCoef = 2.0f;

  // Cursor
  pDrawList->AddCircleFilled(vCursorPos, 5.0f, uBlue, 16);

  // Vertical Line
  if (fScaleY > 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x, oRect.Min.y + fCursorOff), ImVec2(vCursorPos.x, vCursorPos.y - fCursorOff),
                       uOrange, fLineThickness);
  if (fScaleY < 1.0f - 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x, oRect.Max.y - fCursorOff), ImVec2(vCursorPos.x, vCursorPos.y + fCursorOff),
                       uOrange, fLineThickness);

  // Horizontal Line
  if (fScaleX > 2.0f * fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x + fCursorOff, vCursorPos.y), ImVec2(vCursorPos.x - fCursorOff, vCursorPos.y),
                       uOrange, fLineThickness);
  if (fScaleX < 1.0f - 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x - fCursorOff, vCursorPos.y), ImVec2(vCursorPos.x + fCursorOff, vCursorPos.y),
                       uOrange, fLineThickness);

  std::string formatX = ImGui::DataTypeGetInfo(data_type)->PrintFmt;
  std::string formatY = ImGui::DataTypeGetInfo(data_type)->PrintFmt;

  if (IsPositiveScalar(data_type, (ImU64 *) p_valueX)) { formatX = " " + formatX; }
  if (IsPositiveScalar(data_type, (ImU64 *) p_valueY)) { formatY = " " + formatY; }

  char pBufferX[64];
  char pBufferY[64];
  /*const char* value_buf_end_x = pBufferX + */ ImGui::DataTypeFormatString(pBufferX, IM_ARRAYSIZE(pBufferX), data_type,
                                                                            p_valueX, formatX.c_str());
  /*const char* value_buf_end_y = pBufferX + */ ImGui::DataTypeFormatString(pBufferY, IM_ARRAYSIZE(pBufferY), data_type,
                                                                            p_valueY, formatY.c_str());

  ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

  ImGui::SetWindowFontScale(0.75f);

  ImVec2 const vXSize = ImGui::CalcTextSize(pBufferX);
  ImVec2 const vYSize = ImGui::CalcTextSize(pBufferY);

  ImVec2 const vHandlePosX = ImVec2(vCursorPos.x, oRect.Max.y + vYSize.x * 0.5f);
  ImVec2 const vHandlePosY = ImVec2(oRect.Max.x + fHandleOffsetCoef * fCursorOff + vYSize.x, vCursorPos.y);

  ImRect handle_x_bb = ImRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                              vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  ImRect handle_y_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                              vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  pressed = ImGui::ButtonBehavior(handle_x_bb, ImGui::GetID("##HandleX"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vCursorPosLocal = ImGui::GetMousePos() - oRect.Min;

    //*fValueX = vCursorPos.x / (oRect.Max.x - oRect.Min.x) * fDeltaX + fMinX;
    float fValueX = vCursorPosLocal.x / (oRect.Max.x - oRect.Min.x) * ScalarToFloat(data_type, &s_delta_x)
        + ScalarToFloat(data_type, (ImU64 *) p_minX);
    ImU64 s_value_x = FloatToScalar(data_type, fValueX);
    EqualScalar(data_type, (ImU64 *) p_valueX, &s_value_x);

    bModified = true;
  }
  pressed = ImGui::ButtonBehavior(handle_y_bb, ImGui::GetID("##HandleX"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vCursorPosLocal = ImGui::GetMousePos() - oRect.Min;

    //*fValueY = fDeltaY - vCursorPos.y / (oRect.Max.y - oRect.Min.y) * fDeltaY + fMinY;
    float fValueY = ScalarToFloat(data_type, &s_delta_y)
        - vCursorPosLocal.y / (oRect.Max.y - oRect.Min.y) * ScalarToFloat(data_type, &s_delta_y)
        + ScalarToFloat(data_type, (ImU64 *) p_minY);
    ImU64 s_value_y = FloatToScalar(data_type, fValueY);
    EqualScalar(data_type, (ImU64 *) p_valueY, &s_value_y);

    bModified = true;
  }

  pDrawList->AddText(ImVec2(ImMin(ImMax(vCursorPos.x - vXSize.x * 0.5f, oRect.Min.x), oRect.Min.x + vSize.x - vXSize.x),
                            oRect.Max.y + fCursorOff),
                     uTextCol, pBufferX);
  pDrawList->AddText(
      ImVec2(oRect.Max.x + fCursorOff,
             ImMin(ImMax(vCursorPos.y - vYSize.y * 0.5f, oRect.Min.y), oRect.Min.y + vSize.y - vYSize.y)),
      uTextCol, pBufferY);
  ImGui::SetWindowFontScale(1.0f);

  // Borders::Right
  pDrawList->AddCircleFilled(ImVec2(oRect.Max.x, vCursorPos.y), 2.0f, uOrange, 3);
  // Handle Right::Y
  pDrawList->AddNgonFilled(ImVec2(oRect.Max.x + fHandleOffsetCoef * fCursorOff + vYSize.x, vCursorPos.y), fHandleRadius,
                           uBlue, 4);
  if (fScaleY > fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Min.y), ImVec2(oRect.Max.x, vCursorPos.y - fCursorOff), uBlue,
                       fBorderThickness);
  if (fScaleY < 1.0f - fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Max.y), ImVec2(oRect.Max.x, vCursorPos.y + fCursorOff), uBlue,
                       fBorderThickness);
  // Borders::Top
  pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oRect.Min.y), 2.0f, uOrange, 3);
  if (fScaleX > fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(vCursorPos.x - fCursorOff, oRect.Min.y), uBlue,
                       fBorderThickness);
  if (fScaleX < 1.0f - fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Min.y), ImVec2(vCursorPos.x + fCursorOff, oRect.Min.y), uBlue,
                       fBorderThickness);
  // Borders::Left
  pDrawList->AddCircleFilled(ImVec2(oRect.Min.x, vCursorPos.y), 2.0f, uOrange, 3);
  if (fScaleY > fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(oRect.Min.x, vCursorPos.y - fCursorOff), uBlue,
                       fBorderThickness);
  if (fScaleY < 1.0f - fYLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(oRect.Min.x, vCursorPos.y + fCursorOff), uBlue,
                       fBorderThickness);
  // Borders::Bottom
  pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oRect.Max.y), 2.0f, uOrange, 3);
  // Handle Bottom::X
  pDrawList->AddNgonFilled(ImVec2(vCursorPos.x, oRect.Max.y + vXSize.y * 2.0f), fHandleRadius, uBlue, 4);
  if (fScaleX > fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(vCursorPos.x - fCursorOff, oRect.Max.y), uBlue,
                       fBorderThickness);
  if (fScaleX < 1.0f - fXLimit)
    pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Max.y), ImVec2(vCursorPos.x + fCursorOff, oRect.Max.y), uBlue,
                       fBorderThickness);

  ImGui::PopID();

  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vSize);

  return bModified;
}

bool Slider2DInt(char const *pLabel, int *pValueX, int *pValueY, int *p_minX, int *p_maxX, int *p_minY, int *p_maxY,
                 float const fScale) {
  return Slider2DScalar(pLabel, ImGuiDataType_S32, pValueX, pValueY, p_minX, p_maxX, p_minY, p_maxY, fScale);
}
bool Slider2DInt(char const *pLabel, int *pValueX, int *pValueY, int *p_minX, int *p_maxX, int *p_minY, int *p_maxY,
                 ImVec2 size) {
  return Slider2DScalar(pLabel, ImGuiDataType_S32, pValueX, pValueY, p_minX, p_maxX, p_minY, p_maxY, size);
}

bool Slider2DFloat(char const *pLabel, float *pValueX, float *pValueY, float minX, float maxX, float minY, float maxY,
                   float const fScale) {
  return Slider2DScalar(pLabel, ImGuiDataType_Float, pValueX, pValueY, &minX, &maxX, &minY, &maxY, fScale);
}
bool Slider2DFloat(char const *pLabel, float *pValueX, float *pValueY, float minX, float maxX, float minY, float maxY,
                   ImVec2 size) {
  return Slider2DScalar(pLabel, ImGuiDataType_Float, pValueX, pValueY, &minX, &maxX, &minY, &maxY, size);
}

bool Slider2DDouble(char const *pLabel, double *pValueX, double *pValueY, double minX, double maxX, double minY,
                    double maxY, float const fScale) {
  return Slider2DScalar(pLabel, ImGuiDataType_Double, pValueX, pValueY, &minX, &maxX, &minY, &maxY, fScale);
}
bool Slider2DDouble(char const *pLabel, double *pValueX, double *pValueY, double minX, double maxX, double minY,
                    double maxY, ImVec2 size) {
  return Slider2DScalar(pLabel, ImGuiDataType_Double, pValueX, pValueY, &minX, &maxX, &minY, &maxY, size);
}

bool SliderScalar3D(char const *pLabel, float *pValueX, float *pValueY, float *pValueZ, float const fMinX,
                    float const fMaxX, float const fMinY, float const fMaxY, float const fMinZ, float const fMaxZ,
                    ImVec2 size /*= 1.0f*/) {
  assert(fMinX < fMaxX);
  assert(fMinY < fMaxY);
  assert(fMinZ < fMaxZ);

  ImGuiID const iID = ImGui::GetID(pLabel);

  ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;

  if (size.x == 0) {
    float const vSizeFull = ImGui::GetContentRegionAvail().x;
    float const fMinSize = (vSizeFull - vSizeSubstract.x * 0.5f) * 0.75f;
    size.x = fMinSize;
  }
  if (size.y == 0) {
    float const vSizeFull = ImGui::GetContentRegionAvail().x;
    float const fMinSize = (vSizeFull - vSizeSubstract.x * 0.5f) * 0.75f;
    size.y = fMinSize;
  }

  const auto vSize = size;

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos + vHeightOffset, vPos + vSize + vHeightOffset);

  ImGui::Text("%s", pLabel);

  ImGui::PushID(iID);

  ImU32 const uFrameCol = ImGui::GetColorU32(ImGuiCol_FrameBg) | 0xFF000000;
  ImU32 const uFrameCol2 = ImGui::GetColorU32(ImGuiCol_FrameBgActive);

  float &fX = *pValueX;
  float &fY = *pValueY;
  float &fZ = *pValueZ;

  float const fDeltaX = fMaxX - fMinX;
  float const fDeltaY = fMaxY - fMinY;
  float const fDeltaZ = fMaxZ - fMinZ;

  [[maybe_unused]] ImVec2 const vOriginPos = ImGui::GetCursorScreenPos();

  ImDrawList *pDrawList = ImGui::GetWindowDrawList();

  float const fX3 = vSize.x / 3.0f;
  float const fY3 = vSize.y / 3.0f;

  ImVec2 const vStart = oRect.Min;

  ImVec2 aPositions[] = {ImVec2(vStart.x, vStart.y + fX3),
                         ImVec2(vStart.x, vStart.y + vSize.y),
                         ImVec2(vStart.x + 2.0f * fX3, vStart.y + vSize.y),
                         ImVec2(vStart.x + vSize.x, vStart.y + 2.0f * fY3),
                         ImVec2(vStart.x + vSize.x, vStart.y),
                         ImVec2(vStart.x + fX3, vStart.y)};

  pDrawList->AddPolyline(&aPositions[0], 6, uFrameCol2, true, 1.0f);

  // Cube Shape
  pDrawList->AddLine(oRect.Min + ImVec2(0.0f, vSize.y), oRect.Min + ImVec2(fX3, 2.0f * fY3), uFrameCol2, 1.0f);
  pDrawList->AddLine(oRect.Min + ImVec2(fX3, 2.0f * fY3), oRect.Min + ImVec2(vSize.x, 2.0f * fY3), uFrameCol2, 1.0f);
  pDrawList->AddLine(oRect.Min + ImVec2(fX3, 0.0f), oRect.Min + ImVec2(fX3, 2.0f * fY3), uFrameCol2, 1.0f);

  ImGui::PopID();

  constexpr float fDragZOffsetX = 64.0f;

  ImRect oZDragRect(ImVec2(vStart.x + 2.0f * fX3 + fDragZOffsetX, vStart.y + 2.0f * fY3),
                    ImVec2(vStart.x + vSize.x + fDragZOffsetX, vStart.y + vSize.y));

  ImVec2 const vMousePos = ImGui::GetMousePos();
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImVec2 const vDragStart(oZDragRect.Min.x, oZDragRect.Max.y);
  ImVec2 const vDragEnd(oZDragRect.Max.x, oZDragRect.Min.y);
  [[maybe_unused]] ImRect frame_bb = ImRect(oRect.Min - vSecurity, oRect.Max + vSecurity);
  bool bModified = false;
  bool hovered;
  bool held;
  [[maybe_unused]] bool pressed = ImGui::ButtonBehavior(oZDragRect, ImGui::GetID("##HandleZ"), &hovered, &held);
  if (hovered && held) {
    if (DistToSegmentSqr(vMousePos, vDragStart, vDragEnd) < 100.0f)// 100 is arbitrary threshold
    {
      float const fMaxDist = ImSqrt(Dist2(vDragStart, vDragEnd));
      float const fDist = ImSaturate(ImSqrt(DistOnSegmentSqr(vMousePos, vDragStart, vDragEnd)) / fMaxDist);

      fZ = fDist * fDeltaZ * fDist + fMinZ;

      bModified = true;
    }
  }

  float const fScaleZ = (fZ - fMinZ) / fDeltaZ;

  ImVec2 const vRectStart(vStart.x, vStart.y + fX3);
  ImVec2 const vRectEnd(vStart.x + fX3, vStart.y);
  ImRect const oXYDrag((vRectEnd - vRectStart) * fScaleZ + vRectStart,
                       (vRectEnd - vRectStart) * fScaleZ + vRectStart + ImVec2(2.0f * fX3, 2.0f * fY3));
  //if (ImGui::IsMouseHoveringRect(oXYDrag.Min - vSecurity, oXYDrag.Max + vSecurity) && ImGui::IsMouseDown(ImGuiMouseButton_Left))
  pressed = ImGui::ButtonBehavior(oXYDrag, ImGui::GetID("##Zone"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vLocalPos = ImGui::GetMousePos() - oXYDrag.Min;

    fX = vLocalPos.x / (oXYDrag.Max.x - oXYDrag.Min.x) * fDeltaX + fMinX;
    fY = fDeltaY - vLocalPos.y / (oXYDrag.Max.y - oXYDrag.Min.y) * fDeltaY + fMinY;

    bModified = true;
  }

  fX = ImClamp(fX, fMinX, fMaxX);
  fY = ImClamp(fY, fMinY, fMaxY);
  fZ = ImClamp(fZ, fMinZ, fMaxZ);

  float const fScaleX = (fX - fMinX) / fDeltaX;
  float const fScaleY = 1.0f - (fY - fMinY) / fDeltaY;

  ImVec4 const vBlue(70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f);
  ImVec4 const vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f, 1.0f);

  ImS32 const uBlue = ImGui::GetColorU32(vBlue);
  ImS32 const uOrange = ImGui::GetColorU32(vOrange);

  constexpr float fBorderThickness = 2.0f; // TODO: move as Style
  constexpr float fLineThickness = 3.0f;   // TODO: move as Style
  constexpr float fHandleRadius = 7.0f;    // TODO: move as Style
  constexpr float fHandleOffsetCoef = 2.0f;// TODO: move as Style

  pDrawList->AddLine(vDragStart, vDragEnd, uFrameCol2, 1.0f);
  pDrawList->AddRectFilled(oXYDrag.Min, oXYDrag.Max, uFrameCol);

  constexpr float fCursorOff = 10.0f;
  float const fXLimit = fCursorOff / oXYDrag.GetWidth();
  float const fYLimit = fCursorOff / oXYDrag.GetHeight();
  float const fZLimit = fCursorOff / oXYDrag.GetWidth();

  char pBufferX[16];
  char pBufferY[16];
  char pBufferZ[16];
  ImFormatString(pBufferX, IM_ARRAYSIZE(pBufferX), "%.5f", *(float const *) &fX);
  ImFormatString(pBufferY, IM_ARRAYSIZE(pBufferY), "%.5f", *(float const *) &fY);
  ImFormatString(pBufferZ, IM_ARRAYSIZE(pBufferZ), "%.5f", *(float const *) &fZ);

  ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

  ImVec2 const vCursorPos((oXYDrag.Max.x - oXYDrag.Min.x) * fScaleX + oXYDrag.Min.x,
                          (oXYDrag.Max.y - oXYDrag.Min.y) * fScaleY + oXYDrag.Min.y);

  ImGui::SetWindowFontScale(0.75f);

  ImVec2 const vXSize = ImGui::CalcTextSize(pBufferX);
  ImVec2 const vYSize = ImGui::CalcTextSize(pBufferY);
  [[maybe_unused]] ImVec2 const vZSize = ImGui::CalcTextSize(pBufferZ);

  ImVec2 const vTextSlideXMin = oRect.Min + ImVec2(0.0f, vSize.y);
  ImVec2 const vTextSlideXMax = oRect.Min + ImVec2(2.0f * fX3, vSize.y);
  ImVec2 const vXTextPos((vTextSlideXMax - vTextSlideXMin) * fScaleX + vTextSlideXMin);

  ImVec2 const vTextSlideYMin = oRect.Min + ImVec2(vSize.x, 2.0f * fY3);
  ImVec2 const vTextSlideYMax = oRect.Min + ImVec2(vSize.x, 0.0f);
  ImVec2 const vYTextPos((vTextSlideYMax - vTextSlideYMin) * (1.0f - fScaleY) + vTextSlideYMin);

  ImVec2 const vTextSlideZMin = vDragStart + ImVec2(fCursorOff, fCursorOff);
  ImVec2 const vTextSlideZMax = vDragEnd + ImVec2(fCursorOff, fCursorOff);
  ImVec2 const vZTextPos((vTextSlideZMax - vTextSlideZMin) * fScaleZ + vTextSlideZMin);

  ImVec2 const vHandlePosX = vXTextPos + ImVec2(0.0f, vXSize.y + fHandleOffsetCoef * fCursorOff);
  ImVec2 const vHandlePosY = vYTextPos + ImVec2(vYSize.x + (fHandleOffsetCoef + 1.0f) * fCursorOff, 0.0f);

  ImRect handle_x_bb = ImRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                              vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  ImRect handle_y_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                              vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  //ImRect handle_z_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);

  //if (ImGui::IsMouseHoveringRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity) &&
  //	ImGui::IsMouseDown(ImGuiMouseButton_Left))
  pressed = ImGui::ButtonBehavior(handle_x_bb, ImGui::GetID("##HandleX"), &hovered, &held);
  if (hovered && held) {
    float const fCursorPosX = ImGui::GetMousePos().x - vStart.x;

    fX = fDeltaX * fCursorPosX / (2.0f * fX3) + fMinX;

    bModified = true;
  }
  //else if (ImGui::IsMouseHoveringRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity) &&
  //	ImGui::IsMouseDown(ImGuiMouseButton_Left))
  pressed = ImGui::ButtonBehavior(handle_y_bb, ImGui::GetID("##HandleY"), &hovered, &held);
  if (hovered && held) {
    float const fCursorPosY = ImGui::GetMousePos().y - vStart.y;

    fY = fDeltaY * (1.0f - fCursorPosY / (2.0f * fY3)) + fMinY;

    bModified = true;
  }

  pDrawList->AddText(ImVec2(ImMin(ImMax(vXTextPos.x - vXSize.x * 0.5f, vTextSlideXMin.x), vTextSlideXMax.x - vXSize.x),
                            vXTextPos.y + fCursorOff),
                     uTextCol, pBufferX);
  pDrawList->AddText(ImVec2(vYTextPos.x + fCursorOff,
                            ImMin(ImMax(vYTextPos.y - vYSize.y * 0.5f, vTextSlideYMax.y), vTextSlideYMin.y - vYSize.y)),
                     uTextCol, pBufferY);
  pDrawList->AddText(vZTextPos, uTextCol, pBufferZ);
  ImGui::SetWindowFontScale(1.0f);

  // Handles
  pDrawList->AddNgonFilled(vHandlePosX, fHandleRadius, uBlue, 4);
  pDrawList->AddNgonFilled(vHandlePosY, fHandleRadius, uBlue, 4);

  // Vertical Line
  if (fScaleY > 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x, oXYDrag.Min.y + fCursorOff),
                       ImVec2(vCursorPos.x, vCursorPos.y - fCursorOff), uOrange, fLineThickness);
  if (fScaleY < 1.0f - 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x, oXYDrag.Max.y - fCursorOff),
                       ImVec2(vCursorPos.x, vCursorPos.y + fCursorOff), uOrange, fLineThickness);

  // Horizontal Line
  if (fScaleX > 2.0f * fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x + fCursorOff, vCursorPos.y),
                       ImVec2(vCursorPos.x - fCursorOff, vCursorPos.y), uOrange, fLineThickness);
  if (fScaleX < 1.0f - 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x - fCursorOff, vCursorPos.y),
                       ImVec2(vCursorPos.x + fCursorOff, vCursorPos.y), uOrange, fLineThickness);

  // Line To Text
  // X
  if (fScaleZ > 2.0f * fZLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x - 0.5f * fCursorOff, oXYDrag.Max.y + 0.5f * fCursorOff),
                       ImVec2(vXTextPos.x + 0.5f * fCursorOff, vXTextPos.y - 0.5f * fCursorOff), uOrange,
                       fLineThickness);
  else
    pDrawList->AddLine(ImVec2(vCursorPos.x, oXYDrag.Max.y), ImVec2(vXTextPos.x, vXTextPos.y), uOrange, 1.0f);
  pDrawList->AddCircleFilled(vXTextPos, 2.0f, uOrange, 3);
  // Y
  if (fScaleZ < 1.0f - 2.0f * fZLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x + 0.5f * fCursorOff, vCursorPos.y - 0.5f * fCursorOff),
                       ImVec2(vYTextPos.x - 0.5f * fCursorOff, vYTextPos.y + 0.5f * fCursorOff), uOrange,
                       fLineThickness);
  else
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, vCursorPos.y), ImVec2(vYTextPos.x, vYTextPos.y), uOrange, 1.0f);
  pDrawList->AddCircleFilled(vYTextPos, 2.0f, uOrange, 3);

  // Borders::Right
  pDrawList->AddCircleFilled(ImVec2(oXYDrag.Max.x, vCursorPos.y), 2.0f, uOrange, 3);
  if (fScaleY > fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Min.y), ImVec2(oXYDrag.Max.x, vCursorPos.y - fCursorOff), uBlue,
                       fBorderThickness);
  if (fScaleY < 1.0f - fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Max.y), ImVec2(oXYDrag.Max.x, vCursorPos.y + fCursorOff), uBlue,
                       fBorderThickness);
  // Borders::Top
  pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oXYDrag.Min.y), 2.0f, uOrange, 3);
  if (fScaleX > fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Min.y), ImVec2(vCursorPos.x - fCursorOff, oXYDrag.Min.y), uBlue,
                       fBorderThickness);
  if (fScaleX < 1.0f - fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Min.y), ImVec2(vCursorPos.x + fCursorOff, oXYDrag.Min.y), uBlue,
                       fBorderThickness);
  // Borders::Left
  pDrawList->AddCircleFilled(ImVec2(oXYDrag.Min.x, vCursorPos.y), 2.0f, uOrange, 3);
  if (fScaleY > fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Min.y), ImVec2(oXYDrag.Min.x, vCursorPos.y - fCursorOff), uBlue,
                       fBorderThickness);
  if (fScaleY < 1.0f - fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Max.y), ImVec2(oXYDrag.Min.x, vCursorPos.y + fCursorOff), uBlue,
                       fBorderThickness);
  // Borders::Bottom
  pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oXYDrag.Max.y), 2.0f, uOrange, 3);
  if (fScaleX > fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Max.y), ImVec2(vCursorPos.x - fCursorOff, oXYDrag.Max.y), uBlue,
                       fBorderThickness);
  if (fScaleX < 1.0f - fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Max.y), ImVec2(vCursorPos.x + fCursorOff, oXYDrag.Max.y), uBlue,
                       fBorderThickness);

  pDrawList->AddLine(oRect.Min + ImVec2(0.0f, fY3), oRect.Min + ImVec2(2.0f * fX3, fY3), uFrameCol2, 1.0f);
  pDrawList->AddLine(oRect.Min + ImVec2(2.0f * fX3, fY3), oRect.Min + ImVec2(vSize.x, 0.0f), uFrameCol2, 1.0f);
  pDrawList->AddLine(oRect.Min + ImVec2(2.0f * fX3, fY3), oRect.Min + ImVec2(2.0f * fX3, vSize.y), uFrameCol2, 1.0f);

  // Cursor
  pDrawList->AddCircleFilled(vCursorPos, 5.0f, uBlue, 16);
  // CursorZ
  pDrawList->AddNgonFilled((vDragEnd - vDragStart) * fScaleZ + vDragStart, fHandleRadius, uBlue, 4);

  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vHeightOffset * 1.25f);
  ImGui::Dummy(vSize);

  return bModified;
}

bool SliderScalar3D(char const *pLabel, float *pValueX, float *pValueY, float *pValueZ, float const fMinX,
                    float const fMaxX, float const fMinY, float const fMaxY, float const fMinZ, float const fMaxZ,
                    float const fScale /*= 1.0f*/) {
  assert(fMinX < fMaxX);
  assert(fMinY < fMaxY);
  assert(fMinZ < fMaxZ);

  ImGuiID const iID = ImGui::GetID(pLabel);

  ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;

  float const vSizeFull = ImGui::GetContentRegionAvail().x;
  float const fMinSize = (vSizeFull - vSizeSubstract.x * 0.5f) * fScale * 0.75f;
  ImVec2 const vSize(fMinSize, fMinSize);

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos + vHeightOffset, vPos + vSize + vHeightOffset);

  ImGui::Text("%s", pLabel);

  ImGui::PushID(iID);

  ImU32 const uFrameCol = ImGui::GetColorU32(ImGuiCol_FrameBg) | 0xFF000000;
  ImU32 const uFrameCol2 = ImGui::GetColorU32(ImGuiCol_FrameBgActive);

  float &fX = *pValueX;
  float &fY = *pValueY;
  float &fZ = *pValueZ;

  float const fDeltaX = fMaxX - fMinX;
  float const fDeltaY = fMaxY - fMinY;
  float const fDeltaZ = fMaxZ - fMinZ;

  [[maybe_unused]] ImVec2 const vOriginPos = ImGui::GetCursorScreenPos();

  ImDrawList *pDrawList = ImGui::GetWindowDrawList();

  float const fX3 = vSize.x / 3.0f;
  float const fY3 = vSize.y / 3.0f;

  ImVec2 const vStart = oRect.Min;

  ImVec2 aPositions[] = {ImVec2(vStart.x, vStart.y + fX3),
                         ImVec2(vStart.x, vStart.y + vSize.y),
                         ImVec2(vStart.x + 2.0f * fX3, vStart.y + vSize.y),
                         ImVec2(vStart.x + vSize.x, vStart.y + 2.0f * fY3),
                         ImVec2(vStart.x + vSize.x, vStart.y),
                         ImVec2(vStart.x + fX3, vStart.y)};

  pDrawList->AddPolyline(&aPositions[0], 6, uFrameCol2, true, 1.0f);

  // Cube Shape
  pDrawList->AddLine(oRect.Min + ImVec2(0.0f, vSize.y), oRect.Min + ImVec2(fX3, 2.0f * fY3), uFrameCol2, 1.0f);
  pDrawList->AddLine(oRect.Min + ImVec2(fX3, 2.0f * fY3), oRect.Min + ImVec2(vSize.x, 2.0f * fY3), uFrameCol2, 1.0f);
  pDrawList->AddLine(oRect.Min + ImVec2(fX3, 0.0f), oRect.Min + ImVec2(fX3, 2.0f * fY3), uFrameCol2, 1.0f);

  ImGui::PopID();

  constexpr float fDragZOffsetX = 64.0f;

  ImRect oZDragRect(ImVec2(vStart.x + 2.0f * fX3 + fDragZOffsetX, vStart.y + 2.0f * fY3),
                    ImVec2(vStart.x + vSize.x + fDragZOffsetX, vStart.y + vSize.y));

  ImVec2 const vMousePos = ImGui::GetMousePos();
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImVec2 const vDragStart(oZDragRect.Min.x, oZDragRect.Max.y);
  ImVec2 const vDragEnd(oZDragRect.Max.x, oZDragRect.Min.y);
  [[maybe_unused]] ImRect frame_bb = ImRect(oRect.Min - vSecurity, oRect.Max + vSecurity);
  bool bModified = false;
  bool hovered;
  bool held;
  [[maybe_unused]] bool pressed = ImGui::ButtonBehavior(oZDragRect, ImGui::GetID("##HandleZ"), &hovered, &held);
  if (hovered && held) {
    if (DistToSegmentSqr(vMousePos, vDragStart, vDragEnd) < 100.0f)// 100 is arbitrary threshold
    {
      float const fMaxDist = ImSqrt(Dist2(vDragStart, vDragEnd));
      float const fDist = ImSaturate(ImSqrt(DistOnSegmentSqr(vMousePos, vDragStart, vDragEnd)) / fMaxDist);

      fZ = fDist * fDeltaZ * fDist + fMinZ;

      bModified = true;
    }
  }

  float const fScaleZ = (fZ - fMinZ) / fDeltaZ;

  ImVec2 const vRectStart(vStart.x, vStart.y + fX3);
  ImVec2 const vRectEnd(vStart.x + fX3, vStart.y);
  ImRect const oXYDrag((vRectEnd - vRectStart) * fScaleZ + vRectStart,
                       (vRectEnd - vRectStart) * fScaleZ + vRectStart + ImVec2(2.0f * fX3, 2.0f * fY3));
  //if (ImGui::IsMouseHoveringRect(oXYDrag.Min - vSecurity, oXYDrag.Max + vSecurity) && ImGui::IsMouseDown(ImGuiMouseButton_Left))
  pressed = ImGui::ButtonBehavior(oXYDrag, ImGui::GetID("##Zone"), &hovered, &held);
  if (hovered && held) {
    ImVec2 const vLocalPos = ImGui::GetMousePos() - oXYDrag.Min;

    fX = vLocalPos.x / (oXYDrag.Max.x - oXYDrag.Min.x) * fDeltaX + fMinX;
    fY = fDeltaY - vLocalPos.y / (oXYDrag.Max.y - oXYDrag.Min.y) * fDeltaY + fMinY;

    bModified = true;
  }

  fX = ImClamp(fX, fMinX, fMaxX);
  fY = ImClamp(fY, fMinY, fMaxY);
  fZ = ImClamp(fZ, fMinZ, fMaxZ);

  float const fScaleX = (fX - fMinX) / fDeltaX;
  float const fScaleY = 1.0f - (fY - fMinY) / fDeltaY;

  ImVec4 const vBlue(70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f);
  ImVec4 const vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f, 1.0f);

  ImS32 const uBlue = ImGui::GetColorU32(vBlue);
  ImS32 const uOrange = ImGui::GetColorU32(vOrange);

  constexpr float fBorderThickness = 2.0f; // TODO: move as Style
  constexpr float fLineThickness = 3.0f;   // TODO: move as Style
  constexpr float fHandleRadius = 7.0f;    // TODO: move as Style
  constexpr float fHandleOffsetCoef = 2.0f;// TODO: move as Style

  pDrawList->AddLine(vDragStart, vDragEnd, uFrameCol2, 1.0f);
  pDrawList->AddRectFilled(oXYDrag.Min, oXYDrag.Max, uFrameCol);

  constexpr float fCursorOff = 10.0f;
  float const fXLimit = fCursorOff / oXYDrag.GetWidth();
  float const fYLimit = fCursorOff / oXYDrag.GetHeight();
  float const fZLimit = fCursorOff / oXYDrag.GetWidth();

  char pBufferX[16];
  char pBufferY[16];
  char pBufferZ[16];
  ImFormatString(pBufferX, IM_ARRAYSIZE(pBufferX), "%.5f", *(float const *) &fX);
  ImFormatString(pBufferY, IM_ARRAYSIZE(pBufferY), "%.5f", *(float const *) &fY);
  ImFormatString(pBufferZ, IM_ARRAYSIZE(pBufferZ), "%.5f", *(float const *) &fZ);

  ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

  ImVec2 const vCursorPos((oXYDrag.Max.x - oXYDrag.Min.x) * fScaleX + oXYDrag.Min.x,
                          (oXYDrag.Max.y - oXYDrag.Min.y) * fScaleY + oXYDrag.Min.y);

  ImGui::SetWindowFontScale(0.75f);

  ImVec2 const vXSize = ImGui::CalcTextSize(pBufferX);
  ImVec2 const vYSize = ImGui::CalcTextSize(pBufferY);
  [[maybe_unused]] ImVec2 const vZSize = ImGui::CalcTextSize(pBufferZ);

  ImVec2 const vTextSlideXMin = oRect.Min + ImVec2(0.0f, vSize.y);
  ImVec2 const vTextSlideXMax = oRect.Min + ImVec2(2.0f * fX3, vSize.y);
  ImVec2 const vXTextPos((vTextSlideXMax - vTextSlideXMin) * fScaleX + vTextSlideXMin);

  ImVec2 const vTextSlideYMin = oRect.Min + ImVec2(vSize.x, 2.0f * fY3);
  ImVec2 const vTextSlideYMax = oRect.Min + ImVec2(vSize.x, 0.0f);
  ImVec2 const vYTextPos((vTextSlideYMax - vTextSlideYMin) * (1.0f - fScaleY) + vTextSlideYMin);

  ImVec2 const vTextSlideZMin = vDragStart + ImVec2(fCursorOff, fCursorOff);
  ImVec2 const vTextSlideZMax = vDragEnd + ImVec2(fCursorOff, fCursorOff);
  ImVec2 const vZTextPos((vTextSlideZMax - vTextSlideZMin) * fScaleZ + vTextSlideZMin);

  ImVec2 const vHandlePosX = vXTextPos + ImVec2(0.0f, vXSize.y + fHandleOffsetCoef * fCursorOff);
  ImVec2 const vHandlePosY = vYTextPos + ImVec2(vYSize.x + (fHandleOffsetCoef + 1.0f) * fCursorOff, 0.0f);

  ImRect handle_x_bb = ImRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                              vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  ImRect handle_y_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity,
                              vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
  //ImRect handle_z_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);

  //if (ImGui::IsMouseHoveringRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity) &&
  //	ImGui::IsMouseDown(ImGuiMouseButton_Left))
  pressed = ImGui::ButtonBehavior(handle_x_bb, ImGui::GetID("##HandleX"), &hovered, &held);
  if (hovered && held) {
    float const fCursorPosX = ImGui::GetMousePos().x - vStart.x;

    fX = fDeltaX * fCursorPosX / (2.0f * fX3) + fMinX;

    bModified = true;
  }
  //else if (ImGui::IsMouseHoveringRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity) &&
  //	ImGui::IsMouseDown(ImGuiMouseButton_Left))
  pressed = ImGui::ButtonBehavior(handle_y_bb, ImGui::GetID("##HandleY"), &hovered, &held);
  if (hovered && held) {
    float const fCursorPosY = ImGui::GetMousePos().y - vStart.y;

    fY = fDeltaY * (1.0f - fCursorPosY / (2.0f * fY3)) + fMinY;

    bModified = true;
  }

  pDrawList->AddText(ImVec2(ImMin(ImMax(vXTextPos.x - vXSize.x * 0.5f, vTextSlideXMin.x), vTextSlideXMax.x - vXSize.x),
                            vXTextPos.y + fCursorOff),
                     uTextCol, pBufferX);
  pDrawList->AddText(ImVec2(vYTextPos.x + fCursorOff,
                            ImMin(ImMax(vYTextPos.y - vYSize.y * 0.5f, vTextSlideYMax.y), vTextSlideYMin.y - vYSize.y)),
                     uTextCol, pBufferY);
  pDrawList->AddText(vZTextPos, uTextCol, pBufferZ);
  ImGui::SetWindowFontScale(1.0f);

  // Handles
  pDrawList->AddNgonFilled(vHandlePosX, fHandleRadius, uBlue, 4);
  pDrawList->AddNgonFilled(vHandlePosY, fHandleRadius, uBlue, 4);

  // Vertical Line
  if (fScaleY > 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x, oXYDrag.Min.y + fCursorOff),
                       ImVec2(vCursorPos.x, vCursorPos.y - fCursorOff), uOrange, fLineThickness);
  if (fScaleY < 1.0f - 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x, oXYDrag.Max.y - fCursorOff),
                       ImVec2(vCursorPos.x, vCursorPos.y + fCursorOff), uOrange, fLineThickness);

  // Horizontal Line
  if (fScaleX > 2.0f * fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x + fCursorOff, vCursorPos.y),
                       ImVec2(vCursorPos.x - fCursorOff, vCursorPos.y), uOrange, fLineThickness);
  if (fScaleX < 1.0f - 2.0f * fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x - fCursorOff, vCursorPos.y),
                       ImVec2(vCursorPos.x + fCursorOff, vCursorPos.y), uOrange, fLineThickness);

  // Line To Text
  // X
  if (fScaleZ > 2.0f * fZLimit)
    pDrawList->AddLine(ImVec2(vCursorPos.x - 0.5f * fCursorOff, oXYDrag.Max.y + 0.5f * fCursorOff),
                       ImVec2(vXTextPos.x + 0.5f * fCursorOff, vXTextPos.y - 0.5f * fCursorOff), uOrange,
                       fLineThickness);
  else
    pDrawList->AddLine(ImVec2(vCursorPos.x, oXYDrag.Max.y), ImVec2(vXTextPos.x, vXTextPos.y), uOrange, 1.0f);
  pDrawList->AddCircleFilled(vXTextPos, 2.0f, uOrange, 3);
  // Y
  if (fScaleZ < 1.0f - 2.0f * fZLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x + 0.5f * fCursorOff, vCursorPos.y - 0.5f * fCursorOff),
                       ImVec2(vYTextPos.x - 0.5f * fCursorOff, vYTextPos.y + 0.5f * fCursorOff), uOrange,
                       fLineThickness);
  else
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, vCursorPos.y), ImVec2(vYTextPos.x, vYTextPos.y), uOrange, 1.0f);
  pDrawList->AddCircleFilled(vYTextPos, 2.0f, uOrange, 3);

  // Borders::Right
  pDrawList->AddCircleFilled(ImVec2(oXYDrag.Max.x, vCursorPos.y), 2.0f, uOrange, 3);
  if (fScaleY > fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Min.y), ImVec2(oXYDrag.Max.x, vCursorPos.y - fCursorOff), uBlue,
                       fBorderThickness);
  if (fScaleY < 1.0f - fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Max.y), ImVec2(oXYDrag.Max.x, vCursorPos.y + fCursorOff), uBlue,
                       fBorderThickness);
  // Borders::Top
  pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oXYDrag.Min.y), 2.0f, uOrange, 3);
  if (fScaleX > fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Min.y), ImVec2(vCursorPos.x - fCursorOff, oXYDrag.Min.y), uBlue,
                       fBorderThickness);
  if (fScaleX < 1.0f - fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Min.y), ImVec2(vCursorPos.x + fCursorOff, oXYDrag.Min.y), uBlue,
                       fBorderThickness);
  // Borders::Left
  pDrawList->AddCircleFilled(ImVec2(oXYDrag.Min.x, vCursorPos.y), 2.0f, uOrange, 3);
  if (fScaleY > fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Min.y), ImVec2(oXYDrag.Min.x, vCursorPos.y - fCursorOff), uBlue,
                       fBorderThickness);
  if (fScaleY < 1.0f - fYLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Max.y), ImVec2(oXYDrag.Min.x, vCursorPos.y + fCursorOff), uBlue,
                       fBorderThickness);
  // Borders::Bottom
  pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oXYDrag.Max.y), 2.0f, uOrange, 3);
  if (fScaleX > fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Max.y), ImVec2(vCursorPos.x - fCursorOff, oXYDrag.Max.y), uBlue,
                       fBorderThickness);
  if (fScaleX < 1.0f - fXLimit)
    pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Max.y), ImVec2(vCursorPos.x + fCursorOff, oXYDrag.Max.y), uBlue,
                       fBorderThickness);

  pDrawList->AddLine(oRect.Min + ImVec2(0.0f, fY3), oRect.Min + ImVec2(2.0f * fX3, fY3), uFrameCol2, 1.0f);
  pDrawList->AddLine(oRect.Min + ImVec2(2.0f * fX3, fY3), oRect.Min + ImVec2(vSize.x, 0.0f), uFrameCol2, 1.0f);
  pDrawList->AddLine(oRect.Min + ImVec2(2.0f * fX3, fY3), oRect.Min + ImVec2(2.0f * fX3, vSize.y), uFrameCol2, 1.0f);

  // Cursor
  pDrawList->AddCircleFilled(vCursorPos, 5.0f, uBlue, 16);
  // CursorZ
  pDrawList->AddNgonFilled((vDragEnd - vDragStart) * fScaleZ + vDragStart, fHandleRadius, uBlue, 4);

  ImGui::Dummy(vHeightOffset);
  ImGui::Dummy(vHeightOffset * 1.25f);
  ImGui::Dummy(vSize);

  return bModified;
}

bool LineSlider(const char *label, ImVec2 start, ImVec2 end, ImU32 lineColor, ImGuiDataType data_type, void *p_data,
                const void *p_min, const void *p_max, ImWidgetsPointer pointer) {
  ImGuiID iID = ImGui::GetID(label);
  ImGui::PushID(iID);
  ImRect oRect(ImVec2(ImMin(start.x, end.x), ImMin(start.y, end.y)),
               ImVec2(ImMax(start.x, end.x), ImMax(start.y, end.y)));

  [[maybe_unused]] ImVec2 curPos = ImGui::GetCursorScreenPos();
  ImDrawList *pDrawList = ImGui::GetWindowDrawList();

  pDrawList->AddLine(start, end, lineColor, 2.0f);

  float fValue = ScalarToFloat(data_type, (ImU64 *) p_data);
  float fMin = ScalarToFloat(data_type, (ImU64 *) p_min);
  float fMax = ScalarToFloat(data_type, (ImU64 *) p_max);
  float const fBound = fMax - fMin;

  float t = Normalize01(fValue, fMin, fMax);

  ImVec2 cur = ImLerp(start, end, t);

  DrawTrianglePointerFilled(pDrawList, cur, 16.0f, IM_COL32(255, 128, 0, 255), pointer);

  ImVec2 const vMousePos = ImGui::GetMousePos();
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImVec2 const vDragStart(oRect.Min.x, oRect.Max.y);
  ImVec2 const vDragEnd(oRect.Max.x, oRect.Min.y);
  ImRect frame_bb = ImRect(oRect.Min - vSecurity, oRect.Max + vSecurity);

  //pDrawList->AddRect(frame_bb.Min, frame_bb.Max, IM_COL32(0, 255, 0, 255));
  //pDrawList->AddRect(oRect.Min, oRect.Max, IM_COL32(0, 0, 255, 255));

  //ImVec2 vLocalStart(ImMin(vDragStart.x, vDragEnd.x), ImMin(vDragStart.y, vDragEnd.y));
  //ImVec2 vLocalEnd(ImMax(vDragStart.x, vDragEnd.x), ImMax(vDragStart.y, vDragEnd.y));
  ImVec2 vLocalStart = vDragStart;
  ImVec2 vLocalEnd = vDragEnd;

  bool bModified = false;
  bool hovered;
  bool held;
  [[maybe_unused]] bool pressed = ImGui::ButtonBehavior(frame_bb, ImGui::GetID("##DragLineHandle"), &hovered, &held);
  if (hovered && held) {
    //float const fDist = ImSqrt(DistToSegmentSqr(vMousePos, ImVec2(vDragStart.x, vDragEnd.y), ImVec2(vDragEnd.x, vDragStart.y)));
    float const fDist = ImSqrt(DistToSegmentSqr(vMousePos, vLocalStart, vLocalEnd));
    //float const fDist = ImSqrt(DistToSegmentSqr(vMousePos,
    //											ImVec2(ImMax(vDragStart.x, vDragEnd.x), ImMin(vDragStart.y, vDragEnd.y)),
    //											ImVec2(ImMin(vDragStart.x, vDragEnd.x), ImMax(vDragStart.y, vDragEnd.y))));
    if (fDist < 32.0f)// 100 is arbitrary threshold
    {
      float const fMaxDist = ImSqrt(Dist2(vLocalStart, vLocalEnd));
      float const fDist2 = ImSaturate(ImSqrt(DistOnSegmentSqr(vMousePos, vLocalStart, vLocalEnd)) / fMaxDist);

      fValue = fDist2 * fBound * fDist2 + fMin;

      ImU64 uVal = FloatToScalar(data_type, fValue);

      EqualScalar(data_type, (ImU64 *) p_data, &uVal);

      bModified = true;
    }
  }
  ImGui::PopID();

  //ImGui::Dummy(frame_bb.GetSize() + ImVec2(16.0f, 16.0f) * 2.0f);
  //ImGui::SliderScalar(label, data_type, p_data, p_min, p_max);

  return bModified;
}

//////////////////////////////////////////////////////////////////////////

bool Grid2D_AoS_Float(const char *label, float *buffer, int rows, int columns, [[maybe_unused]] float minX,
                      [[maybe_unused]] float maxX, [[maybe_unused]] float minY, [[maybe_unused]] float maxY) {
  assert(minX < maxX);
  assert(minY < maxY);

  ImGuiID const iID = ImGui::GetID(label);
  ImGui::PushID(iID);

  float const vSizeFull = ImGui::GetContentRegionAvail().x;
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImVec2 const vSize(vSizeFull - vSecurity.x, vSizeFull - vSecurity.y);

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos + vSecurity, vPos + vSize);

  float const width = oRect.GetWidth();
  float const height = oRect.GetHeight();

  //ImGui::InvisibleButton("##Zone", oRect.GetSize(), 0);
  ImGui::Dummy(oRect.GetSize());

  bool hovered;
  bool held;

  ImDrawList *pDrawList = ImGui::GetWindowDrawList();
  // Horizontal Line
  for (int j = 0; j < rows; ++j) {
    for (int i = 0; i < columns - 1; ++i) {
      float x0 = buffer[2 * ((j + 0) * columns + i + 0) + 0];
      float y0 = buffer[2 * ((j + 0) * columns + i + 0) + 1];
      float x1 = buffer[2 * ((j + 0) * columns + i + 1) + 0];
      float y1 = buffer[2 * ((j + 0) * columns + i + 1) + 1];

      pDrawList->AddLine(oRect.GetTL() + ImVec2(x0 * width, y0 * height),
                         oRect.GetTL() + ImVec2(x1 * width, y1 * height), IM_COL32(255, 255, 0, 255), 2.0f);
    }
  }
  // Vertical Line
  for (int j = 0; j < rows - 1; ++j) {
    for (int i = 0; i < columns; ++i) {
      float x0 = buffer[2 * ((j + 0) * columns + i + 0) + 0];
      float y0 = buffer[2 * ((j + 0) * columns + i + 0) + 1];
      float x1 = buffer[2 * ((j + 1) * columns + i + 0) + 0];
      float y1 = buffer[2 * ((j + 1) * columns + i + 0) + 1];

      pDrawList->AddLine(oRect.GetTL() + ImVec2(x0 * width, y0 * height),
                         oRect.GetTL() + ImVec2(x1 * width, y1 * height), IM_COL32(255, 255, 0, 255), 2.0f);
    }
  }
  for (int j = 0; j < rows; ++j) {
    for (int i = 0; i < columns; ++i) {
      float *pX = &buffer[2 * (j * columns + i) + 0];
      float *pY = &buffer[2 * (j * columns + i) + 1];

      ImVec2 vCenter = oRect.GetTL() + ImVec2(*pX * width, *pY * height);
      ImRect oLocalRect(vCenter - oRect.GetSize() * 0.01f, vCenter + oRect.GetSize() * 0.01f);

      ImGui::PushID(pX);

      ImGui::ButtonBehavior(oLocalRect, ImGui::GetID(pY), &hovered, &held);
      bool dragged = hovered && held;
      pDrawList->AddCircleFilled(vCenter, vSize.x * 0.01f, IM_COL32(hovered ? 0 : 255, hovered ? 255 : 0, 0, 255), 16);
      if (dragged) {
        ImVec2 vCursorPos = ImGui::GetMousePos();
        ImVec2 vDelta = vCursorPos - oLocalRect.GetCenter();

        vDelta /= oRect.GetSize();

        *pX += vDelta.x;
        *pY += vDelta.y;

        *pX = ImSaturate(*pX);
        *pY = ImSaturate(*pY);
      }

      ImGui::PopID();
    }
  }

  ImGui::Dummy(ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetTextLineHeightWithSpacing()));

  ImGui::PopID();

  return false;
}

bool PlaneMovePoint2D(const char *label, float *buffer_aot, int float2_count, [[maybe_unused]] float minX,
                      [[maybe_unused]] float maxX, [[maybe_unused]] float minY, [[maybe_unused]] float maxY) {
  assert(minX < maxX);
  assert(minY < maxY);

  ImGuiID const iID = ImGui::GetID(label);
  ImGui::PushID(iID);

  float const vSizeFull = ImGui::GetContentRegionAvail().x;
  ImVec2 const vSecurity(15.0f, 15.0f);
  ImVec2 const vSize(vSizeFull - vSecurity.x, vSizeFull - vSecurity.y);

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos + vSecurity, vPos + vSize);

  float const width = oRect.GetWidth();
  float const height = oRect.GetHeight();

  //ImGui::InvisibleButton("##Zone", oRect.GetSize(), 0);
  ImGui::Dummy(oRect.GetSize());

  bool hovered;
  bool held;

  ImDrawList *pDrawList = ImGui::GetWindowDrawList();
  for (int i = 0; i < float2_count; ++i) {
    float *pX = &buffer_aot[2 * i + 0];
    float *pY = &buffer_aot[2 * i + 1];

    ImVec2 vCenter = oRect.GetTL() + ImVec2(*pX * width, *pY * height);
    ImRect oLocalRect(vCenter - oRect.GetSize() * 0.01f, vCenter + oRect.GetSize() * 0.01f);

    ImGui::PushID(pX);

    ImGui::ButtonBehavior(oLocalRect, ImGui::GetID(pY), &hovered, &held);
    bool dragged = hovered && held;
    pDrawList->AddCircleFilled(vCenter, vSize.x * 0.01f, IM_COL32(hovered ? 0 : 255, hovered ? 255 : 0, 0, 255), 16);
    if (dragged) {
      ImVec2 vCursorPos = ImGui::GetMousePos();
      ImVec2 vDelta = vCursorPos - oLocalRect.GetCenter();

      vDelta /= oRect.GetSize();

      *pX += vDelta.x;
      *pY += vDelta.y;

      *pX = ImSaturate(*pX);
      *pY = ImSaturate(*pY);
    }

    ImGui::PopID();
  }

  ImGui::Dummy(ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetTextLineHeightWithSpacing()));

  ImGui::PopID();

  return false;
}

IMGUI_API bool MoveLine2D(const char *label, float *buffer_aot, int float2_count, float minX, float maxX, float minY,
                          float maxY, bool closeLoop) {
  assert(minX < maxX);
  assert(minY < maxY);

  bool modified = false;

  ImGuiID const iID = ImGui::GetID(label);
  ImGui::PushID(iID);

  float const vSizeFull = ImGui::GetContentRegionAvail().x;
  //ImVec2 const vSecurity(15.0f, 15.0f);
  //ImVec2 const vSize(vSizeFull - vSecurity.x, vSizeFull - vSecurity.y);
  ImVec2 const vSize(vSizeFull, vSizeFull);

  float const fHeightOffset = ImGui::GetTextLineHeight();
  ImVec2 const vHeightOffset(0.0f, fHeightOffset);

  ImVec2 vPos = ImGui::GetCursorScreenPos();
  ImRect oRect(vPos, vPos + vSize);

  float const width = oRect.GetWidth();
  float const height = oRect.GetHeight();

  ImGui::Dummy(oRect.GetSize());

  ImDrawList *pDrawList = ImGui::GetWindowDrawList();
  pDrawList->PathClear();
  for (int i = 0; i < float2_count - 1; ++i) {
    float x0 = Rescale(buffer_aot[2 * (i + 0) + 0], minX, maxX, 0.0f, 1.0f);
    float y0 = Rescale(buffer_aot[2 * (i + 0) + 1], minY, maxY, 0.0f, 1.0f);
    float x1 = Rescale(buffer_aot[2 * (i + 1) + 0], minX, maxX, 0.0f, 1.0f);
    float y1 = Rescale(buffer_aot[2 * (i + 1) + 1], minY, maxY, 0.0f, 1.0f);

    pDrawList->AddLine(oRect.GetTL() + ImVec2(x0 * width, y0 * height), oRect.GetTL() + ImVec2(x1 * width, y1 * height),
                       IM_COL32(255, 255, 0, 255), 2.0f);
  }
  if (closeLoop) {
    float x0 = Rescale(buffer_aot[2 * (float2_count - 1) + 0], minX, maxX, 0.0f, 1.0f);
    float y0 = Rescale(buffer_aot[2 * (float2_count - 1) + 1], minY, maxY, 0.0f, 1.0f);
    float x1 = Rescale(buffer_aot[2 * (0) + 0], minX, maxX, 0.0f, 1.0f);
    float y1 = Rescale(buffer_aot[2 * (0) + 1], minY, maxY, 0.0f, 1.0f);

    pDrawList->AddLine(oRect.GetTL() + ImVec2(x0 * width, y0 * height), oRect.GetTL() + ImVec2(x1 * width, y1 * height),
                       IM_COL32(255, 255, 0, 255), 2.0f);
  }

  bool hovered;
  bool held;
  for (int i = 0; i < float2_count; ++i) {
    float *pX = &buffer_aot[2 * i + 0];
    float *pY = &buffer_aot[2 * i + 1];

    float x = Rescale(*pX, minX, maxX, 0.0f, 1.0f);
    float y = Rescale(*pY, minY, maxY, 0.0f, 1.0f);

    ImVec2 vCenter = oRect.GetTL() + ImVec2(x * width, y * height);
    ImRect oLocalRect(vCenter - oRect.GetSize() * 0.01f, vCenter + oRect.GetSize() * 0.01f);

    ImGui::PushID(pX);

    ImGui::ButtonBehavior(oLocalRect, ImGui::GetID(pY), &hovered, &held);
    bool dragged = hovered && held;
    pDrawList->AddCircleFilled(vCenter, vSize.x * 0.01f, IM_COL32(hovered ? 0 : 255, hovered ? 255 : 0, 0, 255), 16);
    if (dragged) {
      ImVec2 vCursorPos = ImGui::GetMousePos();
      ImVec2 vDelta = vCursorPos - oLocalRect.GetCenter();

      vDelta /= oRect.GetSize();

      *pX += vDelta.x;
      *pY += vDelta.y;

      *pX = ImClamp(*pX, minX, maxX);
      *pY = ImClamp(*pY, minY, maxY);

      modified = true;
    }

    ImGui::PopID();
  }

  ImGui::PopID();

  return modified;
}

void DrawHueBand(ImDrawList *pDrawList, ImVec2 const vpos, ImVec2 const size, int division, float alpha, float gamma,
                 float offset) {
  auto HueFunc = [alpha, offset](float const tt) -> ImU32 {
    float t;
    if (tt - offset < 0.0f) t = ImFmod(1.0f + (tt - offset), 1.0f);
    else
      t = ImFmod(tt - offset, 1.0f);

    float r, g, b;
    ImGui::ColorConvertHSVtoRGB(t, 1.0f, 1.0f, r, g, b);
    int const ur = static_cast<int>(255.0f * r);
    int const ug = static_cast<int>(255.0f * g);
    int const ub = static_cast<int>(255.0f * b);
    int const ua = static_cast<int>(255.0f * alpha);
    return IM_COL32(ur, ug, ub, ua);
  };

  DrawColorBandEx<true>(pDrawList, vpos, size, HueFunc, division, gamma);
}

void DrawHueBand(ImDrawList *pDrawList, ImVec2 const vpos, ImVec2 const size, int division, float colorStartRGB[3],
                 float alpha, float gamma) {
  float h, s, v;
  ImGui::ColorConvertRGBtoHSV(colorStartRGB[0], colorStartRGB[1], colorStartRGB[2], h, s, v);
  DrawHueBand(pDrawList, vpos, size, division, alpha, gamma, h);
}

void DrawLumianceBand(ImDrawList *pDrawList, ImVec2 const vpos, ImVec2 const size, int division, ImVec4 const &color,
                      float gamma) {
  float h, s, v;
  ImGui::ColorConvertRGBtoHSV(color.x, color.y, color.z, h, s, v);
  auto LumianceFunc = [h, s, v](float const t) -> ImU32 {
    float r, g, b;
    ImGui::ColorConvertHSVtoRGB(h, s, ImLerp(0.0f, v, t), r, g, b);
    int const ur = static_cast<int>(255.0f * r);
    int const ug = static_cast<int>(255.0f * g);
    int const ub = static_cast<int>(255.0f * b);
    return IM_COL32(ur, ug, ub, 255);
  };

  DrawColorBandEx<true>(pDrawList, vpos, size, LumianceFunc, division, gamma);
}

void DrawSaturationBand(ImDrawList *pDrawList, ImVec2 const vpos, ImVec2 const size, int division, ImVec4 const &color,
                        float gamma) {
  float h, s, v;
  ImGui::ColorConvertRGBtoHSV(color.x, color.y, color.z, h, s, v);
  auto LumianceFunc = [h, s, v](float const t) -> ImU32 {
    float r, g, b;
    ImGui::ColorConvertHSVtoRGB(h, ImLerp(0.0f, 1.0f, t) * s, ImLerp(0.5f, 1.0f, t) * v, r, g, b);
    int const ur = static_cast<int>(255.0f * r);
    int const ug = static_cast<int>(255.0f * g);
    int const ub = static_cast<int>(255.0f * b);
    return IM_COL32(ur, ug, ub, 255);
  };

  DrawColorBandEx<true>(pDrawList, vpos, size, LumianceFunc, division, gamma);
}

bool ColorRing(const char *label, float thickness, int split) {
  ImGuiID const iID = ImGui::GetID(label);
  ImGui::PushID(iID);

  ImVec2 curPos = ImGui::GetCursorScreenPos();
  float const width = ImGui::GetContentRegionAvail().x;
  float const height = width;

  ImGui::InvisibleButton("##Zone", ImVec2(width, height), 0);

  float radius = width * 0.5f;

  const float dAngle = 2.0f * IM_PI / ((float) split);
  float angle = 2.0f * IM_PI / 3.0f;

  ImVec2 offset = curPos + ImVec2(radius, radius);

  ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();
  ImDrawList *pDrawList = ImGui::GetWindowDrawList();
  pDrawList->PrimReserve(split * 6, split * 4);
  for (int i = 0; i < split; ++i) {
    float x0 = radius * ImCos(angle);
    float y0 = radius * ImSin(angle);

    float x1 = radius * ImCos(angle + dAngle);
    float y1 = radius * ImSin(angle + dAngle);

    float x2 = (radius - thickness) * ImCos(angle + dAngle);
    float y2 = (radius - thickness) * ImSin(angle + dAngle);

    float x3 = (radius - thickness) * ImCos(angle);
    float y3 = (radius - thickness) * ImSin(angle);

    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx));
    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx + 1));
    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx + 2));

    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx));
    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx + 2));
    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx + 3));

    float r0, g0, b0;
    float r1, g1, b1;
    ImGui::ColorConvertHSVtoRGB(((float) i) / ((float) (split - 1)), 1.0f, 1.0f, r0, g0, b0);
    ImGui::ColorConvertHSVtoRGB(((float) ((i + 1) % split)) / ((float) (split - 1)), 1.0f, 1.0f, r1, g1, b1);

    pDrawList->PrimWriteVtx(offset + ImVec2(x0, y0), uv, IM_COL32(r0 * 255, g0 * 255, b0 * 255, 255));
    pDrawList->PrimWriteVtx(offset + ImVec2(x1, y1), uv, IM_COL32(r1 * 255, g1 * 255, b1 * 255, 255));
    pDrawList->PrimWriteVtx(offset + ImVec2(x2, y2), uv, IM_COL32(r1 * 255, g1 * 255, b1 * 255, 255));
    pDrawList->PrimWriteVtx(offset + ImVec2(x3, y3), uv, IM_COL32(r0 * 255, g0 * 255, b0 * 255, 255));
    angle += dAngle;
  }
  ImGui::PopID();

  return false;
}

void HueSelectorEx(char const *label, ImVec2 const size, float *hueCenter, float *hueWidth, float *featherLeft,
                   float *featherRight, [[maybe_unused]] ImU32 triangleColor, int division, float alpha,
                   float hideHueAlpha, float offset) {
  ImGuiID const iID = ImGui::GetID(label);
  ImGui::PushID(iID);

  ImGui::Text("%s", label);
  ImVec2 curPos = ImGui::GetCursorScreenPos();
  ImDrawList *pDrawList = ImGui::GetWindowDrawList();
  DrawHueBand(pDrawList, curPos, size, division, alpha, 1.0f, offset);

  float center = ImClamp(ImFmod(*hueCenter + offset, 1.0f), 0.0f, 1.0f - 1e-4f);
  float width = ImClamp(*hueWidth, 0.0f, 0.5f - 1e-4f);
  float featherL = ImClamp(*featherLeft, 0.0f, 0.5f - 1e-4f);
  float featherR = ImClamp(*featherRight, 0.0f, 0.5f - 1e-4f);

  float xCenter = curPos.x + center * size.x;
  float const triangleSize = 16.0f;

  if (width == 0.0f) {
    pDrawList->AddLine(ImVec2(xCenter, curPos.y), ImVec2(xCenter, curPos.y + size.y), IM_COL32(0, 0, 0, 255));
  } else {
    DrawColorDensityPlotEx<true>(
        pDrawList,
        [hueAlpha = hideHueAlpha, center, width, left = featherL, right = featherR](float const xx,
                                                                                    float const) -> ImU32 {
          float x = ImFmod(xx, 1.0f);
          float val;
          if (x < center - width && x > center - width - left) {
            val =
                ImClamp((center * (-1 + hueAlpha) + left + width + x - hueAlpha * (width + x)) / left, hueAlpha, 1.0f);
          } else if (x < center + width + right && x > center + width) {
            val = ImClamp((center - center * hueAlpha + right + width - hueAlpha * width + (-1 + hueAlpha) * x) / right,
                          hueAlpha, 1.0f);
          } else if (x > center - width - left && x < center + width + right) {
            val = 1.0f;
          } else if (center + width + right > 1.0f) {
            val = ImClamp((center - center * hueAlpha + right + width - hueAlpha * width + (-1 + hueAlpha) * (x + 1.0f))
                              / right,
                          hueAlpha, 1.0f);
          } else if (center - width - left < 0.0f) {
            val = ImClamp((center * (-1 + hueAlpha) + left + width + x - 1.0f - hueAlpha * (width + x - 1.0f)) / left,
                          hueAlpha, 1.0f);
          } else {
            val = hueAlpha;
          }
          return IM_COL32(0, 0, 0, ImPow(1.0f - val, 1.0f / 2.2f) * 255);
        },
        0.0f, 1.0f, 0.0f, 0.0f, curPos, size, division, 1);
  }

  ImGui::Dummy(size);

  float const fZero = 0.0f;
  float const fOne = 1.0f;

  float localCenter = center;
  if (LineSlider("##ZoneHueLineSlider", curPos + ImVec2(0.0f, size.y), curPos + ImVec2(size.x, size.y),
                 IM_COL32(255, 255, 255, 255), ImGuiDataType_Float, &localCenter, &fZero, &fOne, ImWidgetsPointer_Up)) {
    if (localCenter - offset < 0.0f) *hueCenter = ImFmod(1.0f + (localCenter - offset), 1.0f);
    else
      *hueCenter = ImFmod(localCenter - offset, 1.0f);
  }
  ImGui::Dummy(ImVec2(size.x, triangleSize));

  ImGui::PushMultiItemsWidths(2, size.x);
  ImGui::DragFloat("##Center", hueCenter, 0.001f, 0.0f, 1.0f);
  ImGui::SameLine();
  ImGui::DragFloat("##Width", hueWidth, 0.001f, 0.0f, 0.5f);

  ImGui::PopID();
}

void HueSelector(char const *label, ImVec2 const size, float *hueCenter, float *hueWidth, float *featherLeft,
                 float *featherRight, int division, float alpha, float hideHueAlpha, float offset) {
  HueSelectorEx(label, size, hueCenter, hueWidth, featherLeft, featherRight, IM_COL32(255, 128, 0, 255), division,
                alpha, hideHueAlpha, offset);
}

// Plots
void AnalyticalPlot(char const *label, float (*func)(float const x), float const minX, float const maxX,
                    int const minSamples) {
  AnalyticalPlotEx(label, func, minX, maxX, minSamples);
}

float FunctionFromData(float const x, float const minX, float const maxX, float *data, int const samples_count) {
  float const t = ImSaturate(Normalize01(x, minX, maxX));

  return LinearSample(t, data, samples_count);
}

ImU32 ImColorFrom_xyz(float x, float y, float z, float *xyzToRGB, float gamma) {
  float r, g, b;
  float maxValue;
  Mat33MulV(&r, &g, &b, x, y, z, xyzToRGB);
  maxValue = ImMax(r, ImMax(g, b));
  if (maxValue > 0.0f) {
    r /= maxValue;
    g /= maxValue;
    b /= maxValue;
  }
  r = ImSaturate(r);
  g = ImSaturate(g);
  b = ImSaturate(b);

  r = ImPow(r, gamma);
  g = ImPow(g, gamma);
  b = ImPow(b, gamma);

  return IM_COL32(r * 255, g * 255, b * 255, 255);
}

static ImVec2 s_ChromaticPlotStart = ImVec2(0.0f, 0.0f);
static ImVec2 s_ChromaticPlotSize = ImVec2(128.0f, 128.0f);
static ImVec2 s_ChromaticPlotBoundMin = ImVec2(0.0f, 0.8f);
static ImVec2 s_ChromaticPlotBoundMax = ImVec2(0.0f, 0.9f);

ImVec4 xyY2XYZ(float x, float y, float Y) {
  if (y > 0.0f) return ImVec4(x * Y / y, Y, (1.0f - x - y) * Y / y, 0.0f);
  else
    return ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
}
ImVec4 XYZ2xyY(float X, float Y, float Z) {
  float const sum = X + Y + Z;
  if (sum > 0.0f) return ImVec4(X / sum, Y / sum, Z / sum, 0.0f);
  else
    return ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
}
ImVec2 XYZ2uvp(float X, float Y, float Z) {
  float const sum = X + 15.0f * Y + 3.0f * Z;
  if (sum > 0.0f) return ImVec2(4.0f * X / sum, 9.0f * Y / sum);
  else
    return ImVec2(0.0f, 0.0f);
}

/*
	ImVec2	GetCIEPoint(float x, float y)
	{
#if 0
		float const z = 1.0f - x - y;

		float const sum = x + 15.0f * y + 3.0f * z;

		x = 4.0f * x / sum;
		y = 9.0f * y / sum;
#else
		return XYZ2xyY(x, y, 0.0f);
#endif

		//return ImVec2(x, y);
	}
	*/

template<bool IsBilinear>
void ChromaticPlotInternalCommon(ImDrawList *pDrawList, ImVec2 const curPos, float width, float height, ImVec2 primR,
                                 ImVec2 primG, ImVec2 primB, ImVec2 whitePoint, float *xyzToRGB,
                                 int const chromeLineSamplesCount, float *observerX, float *observerY, float *observerZ,
                                 int const observerSampleCount, float const observerWavelengthMin,
                                 float const observerWavelengthMax, float *standardCIE,
                                 int const standardCIESampleCount, float const standardCIEWavelengthMin,
                                 float const standardCIEWavelengthMax, float gamma, int resX, int resY, ImU32 maskColor,
                                 float wavelengthMin, float wavelengthMax, float minX, float maxX, float minY,
                                 float maxY) {
  [[maybe_unused]] ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

  DrawColorDensityPlotEx<IsBilinear>(
      pDrawList, [xyzToRGB, gamma](float x, float y) { return ImColorFrom_xyz(x, y, 1.0f - x - y, xyzToRGB, gamma); },
      minX, maxX, minY, maxY, curPos, ImVec2(width, height), resX, resY);

  int lineSamples = ImMin(chromeLineSamplesCount, observerSampleCount);

  float illum;
  float x, y, z;
  float sum;
  ImVector<ImVec2> chromLine;
  chromLine.resize(lineSamples);
  for (int i = 0; i < lineSamples; ++i) {
    float const wavelength =
        ScaleFromNormalized(((float) i) / ((float) (lineSamples - 1)), wavelengthMin, wavelengthMax);

    illum = FunctionFromData(wavelength, standardCIEWavelengthMin, standardCIEWavelengthMax, standardCIE,
                             standardCIESampleCount);
    x = illum
        * FunctionFromData(wavelength, observerWavelengthMin, observerWavelengthMax, observerX, observerSampleCount);
    y = illum
        * FunctionFromData(wavelength, observerWavelengthMin, observerWavelengthMax, observerY, observerSampleCount);
    z = illum
        * FunctionFromData(wavelength, observerWavelengthMin, observerWavelengthMax, observerZ, observerSampleCount);

    sum = x + y + z;
    //sum = x + 15.0f * y + 3.0f * z;

    x /= sum;
    y /= sum;
    //x = 4.0f * x / sum;
    //y = 9.0f * y / sum;

    chromLine[i] = ImVec2(x, y);
  }

  DrawConvexMaskMesh(pDrawList, curPos, ImVec2(width, height), maskColor, (float *) &(chromLine[0].x), lineSamples,
                     minX, maxX, minY, maxY, true);

  ImVec2 sRGBLines[] = {primR, primG, primB};
  for (int i = 0; i < 3; ++i) {
    ImVec2 &vCur = sRGBLines[i];

    vCur.x = curPos.x + Rescale(vCur.x, minX, maxX, 0.0f, width);
    vCur.y = curPos.y + Rescale(vCur.y, minY, maxY, height, 0.0f);
  }
  pDrawList->AddPolyline(&sRGBLines[0], 3, IM_COL32(255, 255, 255, 255), true, 5.0f);

  ImVec2 vWhitePoint = whitePoint;
  vWhitePoint.x = curPos.x + Rescale(vWhitePoint.x, minX, maxX, 0.0f, width);
  vWhitePoint.y = curPos.y + Rescale(vWhitePoint.y, minY, maxY, height, 0.0f);

  pDrawList->AddCircleFilled(vWhitePoint, 5.0f, IM_COL32(0, 0, 0, 255), 4);

  s_ChromaticPlotBoundMin = ImVec2(minX, minY);
  s_ChromaticPlotBoundMax = ImVec2(maxX, maxY);
  s_ChromaticPlotStart = curPos;
  s_ChromaticPlotSize = ImVec2(width, height);
}

void DrawChromaticPlotNearest(ImDrawList *pDrawList, ImVec2 const vPos, float width, float height,
                              int const chromeLineSamplesCount, ImWidgetsColorSpace const colorspace,
                              ImWidgetsObserver const observer, ImWidgetsIlluminance const illum, int resX, int resY,
                              ImU32 maskColor, float wavelengthMin, float wavelengthMax, float minX, float maxX,
                              float minY, float maxY) {
  ChromaticPlotInternalCommon<false>(
      pDrawList, vPos, width, height, s_ColorSpace_Primaries[colorspace][0], s_ColorSpace_Primaries[colorspace][1],
      s_ColorSpace_Primaries[colorspace][2], s_WhitePoints_Values[s_ColorSpace_WhitePointIndex[colorspace]][illum],
      s_ColorSpace_XYZ2RGB[colorspace], chromeLineSamplesCount, s_CIE_Observers_X[observer],
      s_CIE_Observers_Y[observer], s_CIE_Observers_Z[observer], s_CIE_Observers_SamplesCount[observer],
      s_CIE_Observers_min[observer], s_CIE_Observers_max[observer], s_Illums[illum], s_Illums_SamplesCount[illum],
      s_Illums_min[illum], s_Illums_max[illum], 1.0f / s_ColorSpace_Gamma[colorspace], resX, resY, maskColor,
      wavelengthMin, wavelengthMax, minX, maxX, minY, maxY);
}

void DrawChromaticPlotBilinear(ImDrawList *pDrawList, ImVec2 const vPos, float width, float height,
                               int const chromeLineSamplesCount, ImWidgetsColorSpace const colorspace,
                               ImWidgetsObserver const observer, ImWidgetsIlluminance const illum, int resX, int resY,
                               ImU32 maskColor, float wavelengthMin, float wavelengthMax, float minX, float maxX,
                               float minY, float maxY) {
  ChromaticPlotInternalCommon<true>(
      pDrawList, vPos, width, height, s_ColorSpace_Primaries[colorspace][0], s_ColorSpace_Primaries[colorspace][1],
      s_ColorSpace_Primaries[colorspace][2], s_WhitePoints_Values[s_ColorSpace_WhitePointIndex[colorspace]][illum],
      s_ColorSpace_XYZ2RGB[colorspace], chromeLineSamplesCount, s_CIE_Observers_X[observer],
      s_CIE_Observers_Y[observer], s_CIE_Observers_Z[observer], s_CIE_Observers_SamplesCount[observer],
      s_CIE_Observers_min[observer], s_CIE_Observers_max[observer], s_Illums[illum], s_Illums_SamplesCount[illum],
      s_Illums_min[illum], s_Illums_max[illum], 1.0f / s_ColorSpace_Gamma[colorspace], resX, resY, maskColor,
      wavelengthMin, wavelengthMax, minX, maxX, minY, maxY);
}

void DrawChromaticPoint(ImDrawList *pDrawList, ImVec2 const vpos, ImU32 col) {
  ImVec2 vPoint = vpos;

  float x = vPoint.x;
  float y = vPoint.y;
  float const z = 1.0f - x - y;

  float const sum = x + y + z;
  //float const sum = x + 15.0f * y + 3.0f * z;
  //
  //vPoint.x = 4.0f * x / sum;
  //vPoint.y = 9.0f * y / sum;
  vPoint.x = x / sum;
  vPoint.y = y / sum;

  vPoint.x = s_ChromaticPlotStart.x
      + Rescale(vPoint.x, s_ChromaticPlotBoundMin.x, s_ChromaticPlotBoundMax.x, 0.0f, s_ChromaticPlotSize.x);
  vPoint.y = s_ChromaticPlotStart.y
      + Rescale(vPoint.y, s_ChromaticPlotBoundMax.y, s_ChromaticPlotBoundMin.y, 0.0f, s_ChromaticPlotSize.y);
  pDrawList->AddCircleFilled(vPoint, 5.0f, col, 4);
}

IMGUI_API void DrawChromaticLine(ImDrawList *pDrawList, ImVec2 const *vpos, int const pts_counts, ImU32 col,
                                 bool closed, float thickness) {
  ImVector<ImVec2> pts;
  pts.resize(pts_counts);
  ImVec2 const *pCur = vpos;
  for (int i = 0; i < pts_counts; ++i) {
    ImVec2 &vPoint = pts[i];

    //float x = vPoint.x;
    //float y = vPoint.y;
    //float const z = 1.0f - x - y;
    //
    //float const sum = x + 15.0f * y + 3.0f * z;
    //
    //x = 4.0f * x / sum;
    //y = 9.0f * y / sum;
    float x = pCur->x;
    float y = pCur->y;
    //float const z = 1.0f - x - y;
    //float const sum = x + y + z;
    //x = x / sum;
    //y = y / sum;

    vPoint.x = s_ChromaticPlotStart.x
        + Rescale(/*pCur->*/ x, s_ChromaticPlotBoundMin.x, s_ChromaticPlotBoundMax.x, 0.0f, s_ChromaticPlotSize.x);
    vPoint.y = s_ChromaticPlotStart.y
        + Rescale(/*pCur->*/ y, s_ChromaticPlotBoundMax.y, s_ChromaticPlotBoundMin.y, 0.0f, s_ChromaticPlotSize.y);

    ++pCur;
  }
  pDrawList->AddPolyline(&pts[0], pts_counts, col, closed, thickness);
}

void DrawTrianglePointer(ImDrawList *pDrawList, ImVec2 targetPoint, float size, ImU32 col,
                         ImWidgetsPointer pointDirection) {
  constexpr float cos0 = -0.5f;
  constexpr float sin0 = 0.8660254037844386f;

  ImVec2 center;

  if (pointDirection == ImWidgetsPointer_Up) {
    center = targetPoint + ImVec2(0.0f, 1.0f);
    pDrawList->AddTriangle(targetPoint, ImVec2(center.x - cos0 * size, center.y + sin0 * size),
                           ImVec2(center.x + cos0 * size, center.y + sin0 * size), col);
  } else if (pointDirection == ImWidgetsPointer_Down) {
    center = targetPoint + ImVec2(0.0f, -1.0f);
    pDrawList->AddTriangle(targetPoint, ImVec2(center.x + cos0 * size, center.y - sin0 * size),
                           ImVec2(center.x - cos0 * size, center.y - sin0 * size), col);
  } else if (pointDirection == ImWidgetsPointer_Right) {
    center = targetPoint + ImVec2(-1.0f, 0.0f);
    pDrawList->AddTriangle(targetPoint, ImVec2(center.x - sin0 * size, center.y - cos0 * size),
                           ImVec2(center.x - sin0 * size, center.y + cos0 * size), col);
  } else if (pointDirection == ImWidgetsPointer_Left) {
    center = targetPoint + ImVec2(1.0f, 0.0f);
    pDrawList->AddTriangle(targetPoint, ImVec2(center.x + sin0 * size, center.y + cos0 * size),
                           ImVec2(center.x + sin0 * size, center.y - cos0 * size), col);
  }
}

void DrawTrianglePointerFilled(ImDrawList *pDrawList, ImVec2 targetPoint, float size, ImU32 col,
                               ImWidgetsPointer pointDirection) {
  constexpr float cos0 = -0.5f;
  constexpr float sin0 = 0.8660254037844386f;

  ImVec2 center;

  if (pointDirection == ImWidgetsPointer_Up) {
    center = targetPoint + ImVec2(0.0f, 1.0f);
    pDrawList->AddTriangleFilled(targetPoint, ImVec2(center.x - cos0 * size, center.y + sin0 * size),
                                 ImVec2(center.x + cos0 * size, center.y + sin0 * size), col);
  } else if (pointDirection == ImWidgetsPointer_Down) {
    center = targetPoint + ImVec2(0.0f, -1.0f);
    pDrawList->AddTriangleFilled(targetPoint, ImVec2(center.x + cos0 * size, center.y - sin0 * size),
                                 ImVec2(center.x - cos0 * size, center.y - sin0 * size), col);
  } else if (pointDirection == ImWidgetsPointer_Right) {
    center = targetPoint + ImVec2(-1.0f, 0.0f);
    pDrawList->AddTriangleFilled(targetPoint, ImVec2(center.x - sin0 * size, center.y - cos0 * size),
                                 ImVec2(center.x - sin0 * size, center.y + cos0 * size), col);
  } else if (pointDirection == ImWidgetsPointer_Left) {
    center = targetPoint + ImVec2(1.0f, 0.0f);
    pDrawList->AddTriangleFilled(targetPoint, ImVec2(center.x + sin0 * size, center.y + cos0 * size),
                                 ImVec2(center.x + sin0 * size, center.y - cos0 * size), col);
  }
}

// Mask
struct tri {
  ImU16 a;
  ImU16 b;
  ImU16 c;

  tri(ImU16 _a, ImU16 _b, ImU16 _c) : a(_a), b(_b), c(_c) {}
};

IMGUI_API void DrawConvexMaskMesh(ImDrawList *pDrawList, ImVec2 curPos, ImVec2 size, ImU32 maskColor, float *buffer_aot,
                                  int float2_count, float minX, float maxX, float minY, float maxY, bool flipY) {
  ImVec2 bb_pts[4] = {ImVec2(minX, minY), ImVec2(minX, maxY), ImVec2(maxX, maxY), ImVec2(maxX, minY)};

  // Get closer point compare to bb_min;
  float minDist = FLT_MAX;
  int foundIdx = -1;
  ImVec2 *vBuffer = (ImVec2 *) buffer_aot;

  ImVec2 *pCur = vBuffer;
  for (int i = 0; i < float2_count; ++i) {
    ImVec2 const &v = *pCur;
    ++pCur;
    ImVec2 delta = v - bb_pts[0];
    float curDist = ImLengthSqr(delta);
    if (curDist < minDist) {
      minDist = curDist;
      foundIdx = i;
    }
  }

  // Generate triangles
  ImVector<tri> triangles;
  int boundIdx = 0;
  int curIdx = foundIdx;
  int nextIdx = foundIdx + 1;
  nextIdx %= float2_count;
  bool lastConvex = true;
  bool jumped = false;
  do {
    ImVec2 &bnd = bb_pts[boundIdx];
    ImVec2 v0 = vBuffer[curIdx] - bnd;
    ImVec2 v1 = vBuffer[nextIdx] - bnd;
    v0 /= ImLength(v0);
    v1 /= ImLength(v1);
    float crossSignZ = ImSign(v0.x * v1.y - v0.y * v1.x);
    [[maybe_unused]] float dot = v0.x * v1.x + v0.y * v1.y;
    //if (dot > 0.9999999f)
    //if (dot > 0.9999f)
    //{
    //	// If triangle too thin skip it
    //	nextIdx++;
    //	nextIdx %= float2_count;
    //	continue;
    //}
    if (crossSignZ >= 0.0f) {
      // Can be attached to the current corner
      triangles.push_back(tri(float2_count + boundIdx, nextIdx, curIdx));
      curIdx = nextIdx;
      nextIdx++;
      nextIdx %= float2_count;
      lastConvex = true;
    } else {
      // Flipped triangle so use the next corner
      int bnd2 = boundIdx + 1;
      bnd2 %= 4;
      triangles.push_back(tri(float2_count + boundIdx, curIdx, float2_count + bnd2));
      triangles.push_back(tri(float2_count + bnd2, curIdx, nextIdx));
      boundIdx = bnd2;
      curIdx = nextIdx;
      nextIdx++;
      nextIdx %= float2_count;
      lastConvex = false;
      jumped = true;
    }
  } while (!jumped || (nextIdx != (foundIdx + 1) % float2_count && boundIdx != 0));

  if (lastConvex) {
    triangles.push_back(tri(float2_count + 0, foundIdx, float2_count + 3));
  } else {
    tri &lastTri = triangles.back();

    if ((lastTri.b != foundIdx && lastTri.c != foundIdx)) {
      //triangles.push_back(tri(float2_count + 0, (foundIdx + float2_count - 1) % float2_count, (foundIdx + float2_count) % float2_count));
      triangles.push_back(tri(float2_count + 0, (foundIdx + float2_count - 0) % float2_count,
                              (foundIdx + float2_count - 1) % float2_count));
    }
  }
  ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();
  pDrawList->PrimReserve(triangles.size() * 3, float2_count + 4);

  [[maybe_unused]] int triIdx = 0;
  for (tri const &tr : triangles) {
    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx + tr.a));
    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx + tr.b));
    pDrawList->PrimWriteIdx((ImDrawIdx) (pDrawList->_VtxCurrentIdx + tr.c));
  }

  if (flipY) {
    for (int i = 0; i < float2_count; ++i) {
      float x = Rescale(vBuffer[i].x, minX, maxX, 0, size.x);
      float y = Rescale(vBuffer[i].y, maxY, minY, 0, size.y);
      pDrawList->PrimWriteVtx(curPos + ImVec2(x, y), uv, maskColor);
    }
    for (int i = 0; i < 4; ++i) {
      float x = Rescale(bb_pts[i].x, minX, maxX, 0, size.x);
      float y = Rescale(bb_pts[i].y, maxY, minY, 0, size.y);
      pDrawList->PrimWriteVtx(curPos + ImVec2(x, y), uv, maskColor);
    }
  } else {
    for (int i = 0; i < float2_count; ++i) {
      float x = Rescale(vBuffer[i].x, minX, maxX, 0, size.x);
      float y = Rescale(vBuffer[i].y, minY, maxY, 0, size.y);
      pDrawList->PrimWriteVtx(curPos + ImVec2(x, y), uv, maskColor);
    }
    for (int i = 0; i < 4; ++i) {
      float x = Rescale(bb_pts[i].x, minX, maxX, 0, size.x);
      float y = Rescale(bb_pts[i].y, minY, maxY, 0, size.y);
      pDrawList->PrimWriteVtx(curPos + ImVec2(x, y), uv, maskColor);
    }
  }
}

// Density Plots
bool DensityPlotBilinear(const char *label, float (*sample)(float x, float y), int resX, int resY, float minX,
                         float maxX, float minY, float maxY) {
  return DensityPlotEx<true>(label, sample, resX, resY, minX, maxX, minY, maxY);
}
bool DensityPlotNearest(const char *label, float (*sample)(float x, float y), int resX, int resY, float minX,
                        float maxX, float minY, float maxY) {
  return DensityPlotEx<false>(label, sample, resX, resY, minX, maxX, minY, maxY);
}

template<bool IsBilinear>
bool DensityIsolinePlotEx(const char *label, float (*sample)(float x, float y), bool showSurface, float *isoValues,
                          int isoLinesCount, ImU32 *isoLinesColors, int isolinesColorsCount, int resX, int resY,
                          float minX, float maxX, float minY, float maxY) {
  ImGuiID const iID = ImGui::GetID(label);
  ImGui::PushID(iID);

  float *pMin = ImGui::GetStateStorage()->GetFloatRef(iID + 0, FLT_MAX);
  float *pMax = ImGui::GetStateStorage()->GetFloatRef(iID + 1, -FLT_MAX);

  ImVec2 curPos = ImGui::GetCursorScreenPos();
  float const width = ImGui::GetContentRegionAvail().x;
  float const height = width;

  ImGui::InvisibleButton("##Zone", ImVec2(width, height), 0);

  [[maybe_unused]] ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();
  ImDrawList *pDrawList = ImGui::GetWindowDrawList();

  float sx = ((float) width) / ((float) resX);
  float sy = ((float) height) / ((float) resY);
  [[maybe_unused]] float dx = 0.5f * sx;
  [[maybe_unused]] float dy = 0.5f * sx;
  [[maybe_unused]] float r, g, b;
  [[maybe_unused]] float maxValue;
  std::vector<std::vector<bool>> boundaries;// Don't use std::vector<bool> as design
  std::vector<std::vector<float>> coefs;
  boundaries.resize(resY + 1);
  coefs.resize(resY + 1);
  for (int i = 0; i <= resY; ++i) {
    boundaries[i].resize(resX + 1);
    coefs[i].resize(resY + 1);
  }

  if (showSurface) {
    auto GetColor = [pMin, pMax, &sample](float x, float y) {
      float value = sample(x, y);

      if (value < *pMin) *pMin = value;
      if (value > *pMax) *pMax = value;

      float showValue = Normalize01(value, *pMin, *pMax);
      ImU32 const uVal = static_cast<ImU32>(showValue * 255.0f);

      return IM_COL32(uVal, uVal, uVal, 255);
    };

    DrawColorDensityPlotEx<IsBilinear>(pDrawList, GetColor, minX, maxX, minY, maxY, curPos, ImVec2(width, height), resX,
                                       resY);
  }
  for (int k = 0; k < isoLinesCount; ++k) {
    float const isoValue = isoValues[k];
    ImU32 const isoColor = isoLinesColors[k % isolinesColorsCount];

    for (int j = 0; j <= resY; ++j) {
      float y0 = ScaleFromNormalized(1.0f - ((float) (j + 0)) / ((float) (resY - 1)), minY, maxY);

      for (int i = 0; i <= resX; ++i) {
        float x0 = ScaleFromNormalized(((float) (i + 0)) / ((float) (resX - 1)), minX, maxX);
        float const value = sample(x0, y0);
        coefs[j][i] = value;
        boundaries[j][i] = (value >= isoValue);
      }
    }

    for (int j = 1; j <= resY; ++j) {
      for (int i = 1; i <= resX; ++i) {
        int _00 = (int) boundaries[j - 1][i - 1];
        int _10 = (int) boundaries[j - 0][i - 1];
        int _11 = (int) boundaries[j - 0][i - 0];
        int _01 = (int) boundaries[j - 1][i - 0];

        [[maybe_unused]] float _00f = ImAbs(coefs[j - 1][i - 1]);
        [[maybe_unused]] float _10f = ImAbs(coefs[j - 0][i - 1]);
        [[maybe_unused]] float _11f = ImAbs(coefs[j - 0][i - 0]);
        [[maybe_unused]] float _01f = ImAbs(coefs[j - 1][i - 0]);

        int val = (_00 << 0) | (_10 << 1) | (_11 << 2) | (_01 << 3);

        int cnt = 0;
        int src = -1;
        int dst = -1;
        int src2 = -1;
        int dst2 = -1;
        ImVec4 coefs2;
        if (val == 0b0000)// 0
        {
          cnt = 0;
        } else if (val == 0b0010)// 1
        {
          cnt = 1;
          src = 0;
          dst = 1;
        } else if (val == 0b0100)// 2
        {
          cnt = 1;
          src = 1;
          dst = 2;
        } else if (val == 0b0110)// 3
        {
          cnt = 1;
          src = 0;
          dst = 2;
        } else if (val == 0b1000)// 4
        {
          cnt = 1;
          src = 2;
          dst = 3;
        } else if (val == 0b1010)// 5
        {
          cnt = 2;
          src = 1;
          dst = 2;
          src2 = 3;
          dst2 = 0;
        } else if (val == 0b1100)// 6
        {
          cnt = 1;
          src = 1;
          dst = 3;
        } else if (val == 0b1110)// 7
        {
          cnt = 1;
          src = 3;
          dst = 0;
        } else if (val == 0b0001)// 8
        {
          cnt = 1;
          src = 3;
          dst = 0;
        } else if (val == 0b0011)// 9
        {
          cnt = 1;
          src = 1;
          dst = 3;
        } else if (val == 0b0101)// 10
        {
          cnt = 2;
          src = 0;
          dst = 1;
          src2 = 2;
          dst2 = 3;
        } else if (val == 0b0111)// 11
        {
          cnt = 1;
          src = 2;
          dst = 3;
        } else if (val == 0b1001)// 12
        {
          cnt = 1;
          src = 0;
          dst = 2;
        } else if (val == 0b1011)// 13
        {
          cnt = 1;
          src = 1;
          dst = 2;
        } else if (val == 0b1101)// 14
        {
          cnt = 1;
          src = 0;
          dst = 1;
        } else if (val == 0b1111)// 15
        {
          cnt = 0;
        }

        if (cnt > 0) {
          ImVec2 x00 = curPos + ImVec2(sx * (i - 1), sy * (j - 1));
          ImVec2 x01 = curPos + ImVec2(sx * (i - 1), sy * (j + 0));
          ImVec2 x11 = curPos + ImVec2(sx * (i + 0), sy * (j + 0));
          ImVec2 x10 = curPos + ImVec2(sx * (i + 0), sy * (j - 1));

          ImVec2 vals[] = {x00 * 0.5f + x01 * 0.5f, x01 * 0.5f + x11 * 0.5f, x11 * 0.5f + x10 * 0.5f,
                           x10 * 0.5f + x00 * 0.5f};
          //ImVec2 vals[] = {	(x00 * _00f + x01 * _01f) / (_00f + _01f),
          //					(x01 * _01f + x11 * _11f) / (_01f + _11f),
          //					(x11 * _11f + x10 * _10f) / (_11f + _10f),
          //					(x10 * _10f + x00 * _00f) / (_10f + _00f) };
          //ImVec2 vals[] = {	(x00 * _01f + x01 * _00f) / (_00f + _01f),
          //					(x01 * _11f + x11 * _01f) / (_01f + _11f),
          //					(x11 * _10f + x10 * _11f) / (_11f + _10f),
          //					(x10 * _00f + x00 * _10f) / (_10f + _00f) };

          pDrawList->AddLine(vals[src], vals[dst], isoColor, 2.0f);
          if (cnt >= 2) pDrawList->AddLine(vals[src2], vals[dst2], isoColor, 2.0f);
        }
      }
    }
  }

  ImGui::PopID();

  return false;
}

bool DensityIsolinePlotBilinear(const char *label, float (*sample)(float x, float y), bool showSurface, float *isoValue,
                                int isoLinesCount, ImU32 *isoLinesColors, int isolinesColorsCount, int resX, int resY,
                                float minX, float maxX, float minY, float maxY) {
  return DensityIsolinePlotEx<true>(label, sample, showSurface, isoValue, isoLinesCount, isoLinesColors,
                                    isolinesColorsCount, resX, resY, minX, maxX, minY, maxY);
}

//////////////////////////////////////////////////////////////////////////
// External
//////////////////////////////////////////////////////////////////////////
static ImVector<ImRect> s_GroupPanelLabelStack;

void BeginGroupPanel(const char *name, const ImVec2 &size) {
  ImGui::BeginGroup();

  [[maybe_unused]] auto cursorPos = ImGui::GetCursorScreenPos();
  auto itemSpacing = ImGui::GetStyle().ItemSpacing;
  ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
  ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));

  auto frameHeight = ImGui::GetFrameHeight();
  ImGui::BeginGroup();

  ImVec2 effectiveSize = size;
  if (size.x < 0.0f) effectiveSize.x = ImGui::GetContentRegionAvail().x;
  else
    effectiveSize.x = size.x;
  ImGui::Dummy(ImVec2(effectiveSize.x, 0.0f));

  ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
  ImGui::SameLine(0.0f, 0.0f);
  ImGui::BeginGroup();
  ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
  ImGui::SameLine(0.0f, 0.0f);
  ImGui::TextUnformatted(name);
  auto labelMin = ImGui::GetItemRectMin();
  auto labelMax = ImGui::GetItemRectMax();
  ImGui::SameLine(0.0f, 0.0f);
  ImGui::Dummy(ImVec2(0.0, frameHeight + itemSpacing.y));
  ImGui::BeginGroup();

  //ImGui::GetWindowDrawList()->AddRect(labelMin, labelMax, IM_COL32(255, 0, 255, 255));

  ImGui::PopStyleVar(2);

#if IMGUI_VERSION_NUM >= 17301
  ImGui::GetCurrentWindow()->ContentRegionRect.Max.x -= frameHeight * 0.5f;
  ImGui::GetCurrentWindow()->WorkRect.Max.x -= frameHeight * 0.5f;
  ImGui::GetCurrentWindow()->InnerRect.Max.x -= frameHeight * 0.5f;
#else
  ImGui::GetCurrentWindow()->ContentsRegionRect.Max.x -= frameHeight * 0.5f;
#endif
  ImGui::GetCurrentWindow()->Size.x -= frameHeight;

  auto itemWidth = ImGui::CalcItemWidth();
  ImGui::PushItemWidth(ImMax(0.0f, itemWidth - frameHeight));

  s_GroupPanelLabelStack.push_back(ImRect(labelMin, labelMax));
}

void EndGroupPanel() {
  ImGui::PopItemWidth();

  auto itemSpacing = ImGui::GetStyle().ItemSpacing;

  ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
  ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));

  auto frameHeight = ImGui::GetFrameHeight();

  ImGui::EndGroup();

  //ImGui::GetWindowDrawList()->AddRectFilled(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(0, 255, 0, 64), 4.0f);

  ImGui::EndGroup();

  ImGui::SameLine(0.0f, 0.0f);
  ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
  ImGui::Dummy(ImVec2(0.0, frameHeight - frameHeight * 0.5f - itemSpacing.y));

  ImGui::EndGroup();

  auto itemMin = ImGui::GetItemRectMin();
  auto itemMax = ImGui::GetItemRectMax();
  //ImGui::GetWindowDrawList()->AddRectFilled(itemMin, itemMax, IM_COL32(255, 0, 0, 64), 4.0f);

  auto labelRect = s_GroupPanelLabelStack.back();
  s_GroupPanelLabelStack.pop_back();

  ImVec2 halfFrame = ImVec2(frameHeight * 0.25f, frameHeight) * 0.5f;
  ImRect frameRect = ImRect(itemMin + halfFrame, itemMax - ImVec2(halfFrame.x, 0.0f));
  labelRect.Min.x -= itemSpacing.x;
  labelRect.Max.x += itemSpacing.x;
  for (int i = 0; i < 4; ++i) {
    switch (i) {
      // left half-plane
      case 0:
        ImGui::PushClipRect(ImVec2(-FLT_MAX, -FLT_MAX), ImVec2(labelRect.Min.x, FLT_MAX), true);
        break;
        // right half-plane
      case 1:
        ImGui::PushClipRect(ImVec2(labelRect.Max.x, -FLT_MAX), ImVec2(FLT_MAX, FLT_MAX), true);
        break;
        // top
      case 2:
        ImGui::PushClipRect(ImVec2(labelRect.Min.x, -FLT_MAX), ImVec2(labelRect.Max.x, labelRect.Min.y), true);
        break;
        // bottom
      case 3:
        ImGui::PushClipRect(ImVec2(labelRect.Min.x, labelRect.Max.y), ImVec2(labelRect.Max.x, FLT_MAX), true);
        break;
    }

    ImGui::GetWindowDrawList()->AddRect(frameRect.Min, frameRect.Max,
                                        ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), halfFrame.x);

    ImGui::PopClipRect();
  }

  ImGui::PopStyleVar(2);

#if IMGUI_VERSION_NUM >= 17301
  ImGui::GetCurrentWindow()->ContentRegionRect.Max.x += frameHeight * 0.5f;
  ImGui::GetCurrentWindow()->WorkRect.Max.x += frameHeight * 0.5f;
  ImGui::GetCurrentWindow()->InnerRect.Max.x += frameHeight * 0.5f;
#else
  ImGui::GetCurrentWindow()->ContentsRegionRect.Max.x += frameHeight * 0.5f;
#endif
  ImGui::GetCurrentWindow()->Size.x += frameHeight;

  ImGui::Dummy(ImVec2(0.0f, 0.0f));

  ImGui::EndGroup();
}

#if 0
//////////////////////////////////////////////////////////////////////////
	template <int steps>
	void bezier_table(ImVec2 P[4], ImVec2 results[steps + 1])
	{
		static float C[(steps + 1) * 4], * K = 0;
		if (!K)
		{
			K = C;
			for (unsigned step = 0; step <= steps; ++step)
			{
				float t = (float)step / (float)steps;
				C[step * 4 + 0] = (1 - t) * (1 - t) * (1 - t);	// * P0
				C[step * 4 + 1] = 3 * (1 - t) * (1 - t) * t;	// * P1
				C[step * 4 + 2] = 3 * (1 - t) * t * t;			// * P2
				C[step * 4 + 3] = t * t * t;					// * P3
			}
		}
		for (unsigned step = 0; step <= steps; ++step)
		{
			ImVec2 point = {
				K[step * 4 + 0] * P[0].x + K[step * 4 + 1] * P[1].x + K[step * 4 + 2] * P[2].x + K[step * 4 + 3] * P[3].x,
				K[step * 4 + 0] * P[0].y + K[step * 4 + 1] * P[1].y + K[step * 4 + 2] * P[2].y + K[step * 4 + 3] * P[3].y
			};
			results[step] = point;
		}
	}

	float BezierValue(float dt01, float P[4])
	{
		enum { STEPS = 256 };
		ImVec2 Q[4] = { { 0, 0 }, { P[0], P[1] }, { P[2], P[3] }, { 1, 1 } };
		ImVec2 results[STEPS + 1];
		bezier_table<STEPS>(Q, results);
		return results[(int)((dt01 < 0 ? 0 : dt01 > 1 ? 1 : dt01) * STEPS)].y;
	}

	int Bezier(const char* label, float P[5])
	{
		// visuals
		enum { SMOOTHNESS = 64 }; // curve smoothness: the higher number of segments, the smoother curve
		enum { CURVE_WIDTH = 4 }; // main curved line width
		enum { LINE_WIDTH = 1 }; // handlers: small lines width
		enum { GRAB_RADIUS = 8 }; // handlers: circle radius
		enum { GRAB_BORDER = 2 }; // handlers: circle border width
		enum { AREA_CONSTRAINED = true }; // should grabbers be constrained to grid area?
		enum { AREA_WIDTH = 128 }; // area width in pixels. 0 for adaptive size (will use max avail width)

		// curve presets
		static struct { const char* name; float points[4]; } presets[] = {
			{ "Linear", 0.000f, 0.000f, 1.000f, 1.000f },

			{ "In Sine", 0.470f, 0.000f, 0.745f, 0.715f },
			{ "In Quad", 0.550f, 0.085f, 0.680f, 0.530f },
			{ "In Cubic", 0.550f, 0.055f, 0.675f, 0.190f },
			{ "In Quart", 0.895f, 0.030f, 0.685f, 0.220f },
			{ "In Quint", 0.755f, 0.050f, 0.855f, 0.060f },
			{ "In Expo", 0.950f, 0.050f, 0.795f, 0.035f },
			{ "In Circ", 0.600f, 0.040f, 0.980f, 0.335f },
			{ "In Back", 0.600f, -0.28f, 0.735f, 0.045f },

			{ "Out Sine", 0.390f, 0.575f, 0.565f, 1.000f },
			{ "Out Quad", 0.250f, 0.460f, 0.450f, 0.940f },
			{ "Out Cubic", 0.215f, 0.610f, 0.355f, 1.000f },
			{ "Out Quart", 0.165f, 0.840f, 0.440f, 1.000f },
			{ "Out Quint", 0.230f, 1.000f, 0.320f, 1.000f },
			{ "Out Expo", 0.190f, 1.000f, 0.220f, 1.000f },
			{ "Out Circ", 0.075f, 0.820f, 0.165f, 1.000f },
			{ "Out Back", 0.175f, 0.885f, 0.320f, 1.275f },

			{ "InOut Sine", 0.445f, 0.050f, 0.550f, 0.950f },
			{ "InOut Quad", 0.455f, 0.030f, 0.515f, 0.955f },
			{ "InOut Cubic", 0.645f, 0.045f, 0.355f, 1.000f },
			{ "InOut Quart", 0.770f, 0.000f, 0.175f, 1.000f },
			{ "InOut Quint", 0.860f, 0.000f, 0.070f, 1.000f },
			{ "InOut Expo", 1.000f, 0.000f, 0.000f, 1.000f },
			{ "InOut Circ", 0.785f, 0.135f, 0.150f, 0.860f },
			{ "InOut Back", 0.680f, -0.55f, 0.265f, 1.550f },

			// easeInElastic: not a bezier
			// easeOutElastic: not a bezier
			// easeInOutElastic: not a bezier
			// easeInBounce: not a bezier
			// easeOutBounce: not a bezier
			// easeInOutBounce: not a bezier
		};

		// preset selector

		bool reload = 0;
		ImGui::PushID(label);
		if (ImGui::ArrowButton("##lt", ImGuiDir_Left))
		{ // ImGui::ArrowButton(ImGui::GetCurrentWindow()->GetID("##lt"), ImGuiDir_Left, ImVec2(0, 0), 0)
			if (--P[4] >= 0) reload = 1; else ++P[4];
		}
		ImGui::SameLine();

		if (ImGui::Button("Presets"))
		{
			ImGui::OpenPopup("!Presets");
		}
		if (ImGui::BeginPopup("!Presets"))
		{
			for (int i = 0; i < IM_ARRAYSIZE(presets); ++i)
			{
				if (i == 1 || i == 9 || i == 17) ImGui::Separator();
				if (ImGui::MenuItem(presets[i].name, NULL, P[4] == i))
				{
					P[4] = i;
					reload = 1;
				}
			}
			ImGui::EndPopup();
		}
		ImGui::SameLine();

		if (ImGui::ArrowButton("##rt", ImGuiDir_Right))
		{ // ImGui::ArrowButton(ImGui::GetCurrentWindow()->GetID("##rt"), ImGuiDir_Right, ImVec2(0, 0), 0)
			if (++P[4] < IM_ARRAYSIZE(presets)) reload = 1; else --P[4];
		}
		ImGui::SameLine();
		ImGui::PopID();

		if (reload)
		{
			memcpy(P, presets[(int)P[4]].points, sizeof(float) * 4);
		}

		// bezier widget

		const ImGuiStyle& Style = ImGui::GetStyle();
		const ImGuiIO& IO = ImGui::GetIO();
		ImDrawList* DrawList = ImGui::GetWindowDrawList();
		ImGuiWindow* Window = ImGui::GetCurrentWindow();
		if (Window->SkipItems)
			return false;

		// header and spacing
		int changed = ImGui::SliderFloat4(label, P, 0, 1, "%.3f", 1.0f);
		int hovered = ImGui::IsItemActive() || ImGui::IsItemHovered(); // IsItemDragged() ?
		ImGui::Dummy(ImVec2(0, 3));

		// prepare canvas
		//const float avail = ImGui::GetContentRegionAvailWidth();
		float const avail = ImGui::GetContentRegionAvail().x;
		const float dim = AREA_WIDTH > 0 ? AREA_WIDTH : avail;
		ImVec2 Canvas(dim, dim);

		ImRect bb(Window->DC.CursorPos, Window->DC.CursorPos + Canvas);
		ImGui::ItemSize(bb);
		if (!ImGui::ItemAdd(bb, NULL))
			return changed;

		const ImGuiID id = Window->GetID(label);
		hovered |= 0 != ImGui::ItemHoverable(ImRect(bb.Min, bb.Min + ImVec2(avail, dim)), id);

		ImGui::RenderFrame(bb.Min, bb.Max, ImGui::GetColorU32(ImGuiCol_FrameBg, 1), true, Style.FrameRounding);

		// background grid
		for (int i = 0; i <= Canvas.x; i += (Canvas.x / 4))
		{
			DrawList->AddLine(
				ImVec2(bb.Min.x + i, bb.Min.y),
				ImVec2(bb.Min.x + i, bb.Max.y),
				ImGui::GetColorU32(ImGuiCol_TextDisabled));
		}
		for (int i = 0; i <= Canvas.y; i += (Canvas.y / 4))
		{
			DrawList->AddLine(
				ImVec2(bb.Min.x, bb.Min.y + i),
				ImVec2(bb.Max.x, bb.Min.y + i),
				ImGui::GetColorU32(ImGuiCol_TextDisabled));
		}

		// eval curve
		ImVec2 Q[4] = { { 0, 0 }, { P[0], P[1] }, { P[2], P[3] }, { 1, 1 } };
		ImVec2 results[SMOOTHNESS + 1];
		bezier_table<SMOOTHNESS>(Q, results);

		// control points: 2 lines and 2 circles
		{
			// handle grabbers
			ImVec2 mouse = ImGui::GetIO().MousePos, pos[2];
			float distance[2];

			for (int i = 0; i < 2; ++i)
			{
				pos[i] = ImVec2(P[i * 2 + 0], 1 - P[i * 2 + 1]) * (bb.Max - bb.Min) + bb.Min;
				distance[i] = (pos[i].x - mouse.x) * (pos[i].x - mouse.x) + (pos[i].y - mouse.y) * (pos[i].y - mouse.y);
			}

			int selected = distance[0] < distance[1] ? 0 : 1;
			if (distance[selected] < (4 * GRAB_RADIUS * 4 * GRAB_RADIUS))
			{
				ImGui::SetTooltip("(%4.3f, %4.3f)", P[selected * 2 + 0], P[selected * 2 + 1]);

				if (/*hovered &&*/ (ImGui::IsMouseClicked(0) || ImGui::IsMouseDragging(0)))
				{
					float& px = (P[selected * 2 + 0] += ImGui::GetIO().MouseDelta.x / Canvas.x);
					float& py = (P[selected * 2 + 1] -= ImGui::GetIO().MouseDelta.y / Canvas.y);

					if constexpr (AREA_CONSTRAINED) {
						px = (px < 0 ? 0 : (px > 1 ? 1 : px));
						py = (py < 0 ? 0 : (py > 1 ? 1 : py));
					}

					changed = true;
				}
			}
		}

		// if (hovered || changed) DrawList->PushClipRectFullScreen();

		// draw curve
		{
			ImColor color(ImGui::GetStyle().Colors[ImGuiCol_PlotLines]);
			for (int i = 0; i < SMOOTHNESS; ++i) {
				ImVec2 p = { results[i + 0].x, 1 - results[i + 0].y };
				ImVec2 q = { results[i + 1].x, 1 - results[i + 1].y };
				ImVec2 r(p.x * (bb.Max.x - bb.Min.x) + bb.Min.x, p.y * (bb.Max.y - bb.Min.y) + bb.Min.y);
				ImVec2 s(q.x * (bb.Max.x - bb.Min.x) + bb.Min.x, q.y * (bb.Max.y - bb.Min.y) + bb.Min.y);
				DrawList->AddLine(r, s, color, CURVE_WIDTH);
			}
		}

		// draw preview (cycles every 1s)
		static clock_t epoch = clock();
		ImVec4 white(ImGui::GetStyle().Colors[ImGuiCol_Text]);
		for (int i = 0; i < 3; ++i)
		{
			double now = ((clock() - epoch) / (double)CLOCKS_PER_SEC);
			float delta = ((int)(now * 1000) % 1000) / 1000.f; delta += i / 3.f; if (delta > 1) delta -= 1;
			int idx = (int)(delta * SMOOTHNESS);
			float evalx = results[idx].x; // 
			float evaly = results[idx].y; // ImGui::BezierValue( delta, P );
			ImVec2 p0 = ImVec2(evalx, 1 - 0) * (bb.Max - bb.Min) + bb.Min;
			ImVec2 p1 = ImVec2(0, 1 - evaly) * (bb.Max - bb.Min) + bb.Min;
			ImVec2 p2 = ImVec2(evalx, 1 - evaly) * (bb.Max - bb.Min) + bb.Min;
			DrawList->AddCircleFilled(p0, GRAB_RADIUS / 2, ImColor(white));
			DrawList->AddCircleFilled(p1, GRAB_RADIUS / 2, ImColor(white));
			DrawList->AddCircleFilled(p2, GRAB_RADIUS / 2, ImColor(white));
		}

		// draw lines and grabbers
		float luma = ImGui::IsItemActive() || ImGui::IsItemHovered() ? 0.5f : 1.0f;
		ImVec4 pink(1.00f, 0.00f, 0.75f, luma), cyan(0.00f, 0.75f, 1.00f, luma);
		ImVec2 p1 = ImVec2(P[0], 1 - P[1]) * (bb.Max - bb.Min) + bb.Min;
		ImVec2 p2 = ImVec2(P[2], 1 - P[3]) * (bb.Max - bb.Min) + bb.Min;
		DrawList->AddLine(ImVec2(bb.Min.x, bb.Max.y), p1, ImColor(white), LINE_WIDTH);
		DrawList->AddLine(ImVec2(bb.Max.x, bb.Min.y), p2, ImColor(white), LINE_WIDTH);
		DrawList->AddCircleFilled(p1, GRAB_RADIUS, ImColor(white));
		DrawList->AddCircleFilled(p1, GRAB_RADIUS - GRAB_BORDER, ImColor(pink));
		DrawList->AddCircleFilled(p2, GRAB_RADIUS, ImColor(white));
		DrawList->AddCircleFilled(p2, GRAB_RADIUS - GRAB_BORDER, ImColor(cyan));

		// if (hovered || changed) DrawList->PopClipRect();

		return changed;
	}

	void ShowBezierDemo() {
		{ static float v[5] = { 0.950f, 0.050f, 0.795f, 0.035f }; Bezier("easeInExpo", v); }
	}

	//////////////////////////////////////////////////////////////////////////
	constexpr float NODE_SLOT_RADIUS = 4.0f;

	int CurveEditor(const char* label,
					float* values,
					int points_count,
					const ImVec2& editor_size,
					ImU32 flags,
					int* new_count)
	{
		enum class StorageValues : ImGuiID
		{
			FROM_X = 100,
			FROM_Y,
			WIDTH,
			HEIGHT,
			IS_PANNING,
			POINT_START_X,
			POINT_START_Y
		};

		const float HEIGHT = 100;
		static ImVec2 start_pan;

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		ImVec2 size = editor_size;
		size.x = size.x < 0 ? ImGui::CalcItemWidth() + (style.FramePadding.x * 2) : size.x;
		size.y = size.y < 0 ? HEIGHT : size.y;

		ImGuiWindow* parent_window = ImGui::GetCurrentWindow();
		ImGuiID id = parent_window->GetID(label);
		if (!ImGui::BeginChildFrame(id, size, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse))
		{
			ImGui::EndChild();
			return -1;
		}

		int hovered_idx = -1;
		if (new_count)* new_count = points_count;

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if (window->SkipItems)
		{
			ImGui::EndChild();
			return -1;
		}

		ImVec2 points_min(FLT_MAX, FLT_MAX);
		ImVec2 points_max(-FLT_MAX, -FLT_MAX);
		for (int point_idx = 0; point_idx < points_count; ++point_idx)
		{
			ImVec2 point;
			if (flags & (int)CurveEditorFlags::NO_TANGENTS)
			{
				point = ((ImVec2*)values)[point_idx];
			}
			else
			{
				point = ((ImVec2*)values)[1 + point_idx * 3];
			}
			points_max = ImMax(points_max, point);
			points_min = ImMin(points_min, point);
		}
		points_max.y = ImMax(points_max.y, points_min.y + 0.0001f);

		float from_x = window->StateStorage.GetFloat((ImGuiID)StorageValues::FROM_X, points_min.x);
		float from_y = window->StateStorage.GetFloat((ImGuiID)StorageValues::FROM_Y, points_min.y);
		float width = window->StateStorage.GetFloat((ImGuiID)StorageValues::WIDTH, points_max.x - points_min.x);
		float height = window->StateStorage.GetFloat((ImGuiID)StorageValues::HEIGHT, points_max.y - points_min.y);
		window->StateStorage.SetFloat((ImGuiID)StorageValues::FROM_X, from_x);
		window->StateStorage.SetFloat((ImGuiID)StorageValues::FROM_Y, from_y);
		window->StateStorage.SetFloat((ImGuiID)StorageValues::WIDTH, width);
		window->StateStorage.SetFloat((ImGuiID)StorageValues::HEIGHT, height);

		ImVec2 beg_pos = ImGui::GetCursorScreenPos();

		const ImRect inner_bb = window->InnerRect;
		const ImRect frame_bb(inner_bb.Min - style.FramePadding, inner_bb.Max + style.FramePadding);

		auto transform = [&](const ImVec2& pos) -> ImVec2
		{
			float x = (pos.x - from_x) / width;
			float y = (pos.y - from_y) / height;

			return ImVec2(
				inner_bb.Min.x * (1 - x) + inner_bb.Max.x * x,
				inner_bb.Min.y * y + inner_bb.Max.y * (1 - y)
			);
		};

		auto invTransform = [&](const ImVec2& pos) -> ImVec2
		{
			float x = (pos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x);
			float y = (inner_bb.Max.y - pos.y) / (inner_bb.Max.y - inner_bb.Min.y);

			return ImVec2(
				from_x + width * x,
				from_y + height * y
			);
		};

		if (flags & (int)CurveEditorFlags::SHOW_GRID)
		{
			int exp;
			frexp(width / 5, &exp);
			float step_x = (float)ldexp(1.0, exp);
			int cell_cols = int(width / step_x);

			float x = step_x * int(from_x / step_x);
			for (int i = -1; i < cell_cols + 2; ++i)
			{
				ImVec2 a = transform({ x + i * step_x, from_y });
				ImVec2 b = transform({ x + i * step_x, from_y + height });
				window->DrawList->AddLine(a, b, 0x55000000);
				char buf[64];
				if (exp > 0)
				{
					ImFormatString(buf, sizeof(buf), " %d", int(x + i * step_x));
				}
				else
				{
					ImFormatString(buf, sizeof(buf), " %f", x + i * step_x);
				}
				window->DrawList->AddText(b, 0x55000000, buf);
			}

			frexp(height / 5, &exp);
			float step_y = (float)ldexp(1.0, exp);
			int cell_rows = int(height / step_y);

			float y = step_y * int(from_y / step_y);
			for (int i = -1; i < cell_rows + 2; ++i)
			{
				ImVec2 a = transform({ from_x, y + i * step_y });
				ImVec2 b = transform({ from_x + width, y + i * step_y });
				window->DrawList->AddLine(a, b, 0x55000000);
				char buf[64];
				if (exp > 0)
				{
					ImFormatString(buf, sizeof(buf), " %d", int(y + i * step_y));
				}
				else
				{
					ImFormatString(buf, sizeof(buf), " %f", y + i * step_y);
				}
				window->DrawList->AddText(a, 0x55000000, buf);
			}
		}

		if (ImGui::GetIO().MouseWheel != 0 && ImGui::IsItemHovered())
		{
			float scale = powf(2, ImGui::GetIO().MouseWheel);
			width *= scale;
			height *= scale;
			window->StateStorage.SetFloat((ImGuiID)StorageValues::WIDTH, width);
			window->StateStorage.SetFloat((ImGuiID)StorageValues::HEIGHT, height);
		}
		if (ImGui::IsMouseReleased(1))
		{
			window->StateStorage.SetBool((ImGuiID)StorageValues::IS_PANNING, false);
		}
		if (window->StateStorage.GetBool((ImGuiID)StorageValues::IS_PANNING, false))
		{
			ImVec2 drag_offset = ImGui::GetMouseDragDelta(1);
			from_x = start_pan.x;
			from_y = start_pan.y;
			from_x -= drag_offset.x * width / (inner_bb.Max.x - inner_bb.Min.x);
			from_y += drag_offset.y * height / (inner_bb.Max.y - inner_bb.Min.y);
			window->StateStorage.SetFloat((ImGuiID)StorageValues::FROM_X, from_x);
			window->StateStorage.SetFloat((ImGuiID)StorageValues::FROM_Y, from_y);
		}
		else if (ImGui::IsMouseDragging(1) && ImGui::IsItemHovered())
		{
			window->StateStorage.SetBool((ImGuiID)StorageValues::IS_PANNING, true);
			start_pan.x = from_x;
			start_pan.y = from_y;
		}

		int changed_idx = -1;
		for (int point_idx = points_count - 2; point_idx >= 0; --point_idx)
		{
			ImVec2* points;
			if (flags & (int)CurveEditorFlags::NO_TANGENTS)
			{
				points = ((ImVec2*)values) + point_idx;
			}
			else
			{
				points = ((ImVec2*)values) + 1 + point_idx * 3;
			}

			ImVec2 p_prev = points[0];
			ImVec2 tangent_last;
			ImVec2 tangent;
			ImVec2 p;
			if (flags & (int)CurveEditorFlags::NO_TANGENTS)
			{
				p = points[1];
			}
			else
			{
				tangent_last = points[1];
				tangent = points[2];
				p = points[3];
			}

			auto handlePoint = [&](ImVec2& p, int idx) -> bool
			{
				static const float SIZE = 3;

				ImVec2 cursor_pos = ImGui::GetCursorScreenPos();
				ImVec2 pos = transform(p);

				ImGui::SetCursorScreenPos(pos - ImVec2(SIZE, SIZE));
				ImGui::PushID(idx);
				ImGui::InvisibleButton("", ImVec2(2 * NODE_SLOT_RADIUS, 2 * NODE_SLOT_RADIUS));

				ImU32 col = ImGui::IsItemActive() || ImGui::IsItemHovered() ? ImGui::GetColorU32(ImGuiCol_PlotLinesHovered) : ImGui::GetColorU32(ImGuiCol_PlotLines);

				window->DrawList->AddLine(pos + ImVec2(-SIZE, 0), pos + ImVec2(0, SIZE), col);
				window->DrawList->AddLine(pos + ImVec2(SIZE, 0), pos + ImVec2(0, SIZE), col);
				window->DrawList->AddLine(pos + ImVec2(SIZE, 0), pos + ImVec2(0, -SIZE), col);
				window->DrawList->AddLine(pos + ImVec2(-SIZE, 0), pos + ImVec2(0, -SIZE), col);

				if (ImGui::IsItemHovered()) hovered_idx = point_idx + idx;

				bool changed = false;
				if (ImGui::IsItemActive() && ImGui::IsMouseClicked(0))
				{
					window->StateStorage.SetFloat((ImGuiID)StorageValues::POINT_START_X, pos.x);
					window->StateStorage.SetFloat((ImGuiID)StorageValues::POINT_START_Y, pos.y);
				}

				if (ImGui::IsItemHovered() || ImGui::IsItemActive() && ImGui::IsMouseDragging(0))
				{
					char tmp[64];
					ImFormatString(tmp, sizeof(tmp), "%0.2f, %0.2f", p.x, p.y);
					window->DrawList->AddText({ pos.x, pos.y - ImGui::GetTextLineHeight() }, 0xff000000, tmp);
				}

				if (ImGui::IsItemActive() && ImGui::IsMouseDragging(0))
				{
					pos.x = window->StateStorage.GetFloat((ImGuiID)StorageValues::POINT_START_X, pos.x);
					pos.y = window->StateStorage.GetFloat((ImGuiID)StorageValues::POINT_START_Y, pos.y);
					pos += ImGui::GetMouseDragDelta();
					ImVec2 v = invTransform(pos);

					p = v;
					changed = true;
				}
				ImGui::PopID();

				ImGui::SetCursorScreenPos(cursor_pos);
				return changed;
			};

			auto handleTangent = [&](ImVec2& t, const ImVec2& p, int idx) -> bool
			{
				static const float SIZE = 2;
				static const float LENGTH = 18;

				auto normalized = [](const ImVec2& v) -> ImVec2
				{
					float len = 1.0f / sqrtf(v.x * v.x + v.y * v.y);
					return ImVec2(v.x * len, v.y * len);
				};

				ImVec2 cursor_pos = ImGui::GetCursorScreenPos();
				ImVec2 pos = transform(p);
				ImVec2 tang = pos + normalized(ImVec2(t.x, -t.y)) * LENGTH;

				ImGui::SetCursorScreenPos(tang - ImVec2(SIZE, SIZE));
				ImGui::PushID(-idx);
				ImGui::InvisibleButton("", ImVec2(2 * NODE_SLOT_RADIUS, 2 * NODE_SLOT_RADIUS));

				window->DrawList->AddLine(pos, tang, ImGui::GetColorU32(ImGuiCol_PlotLines));

				ImU32 col = ImGui::IsItemHovered() ? ImGui::GetColorU32(ImGuiCol_PlotLinesHovered) : ImGui::GetColorU32(ImGuiCol_PlotLines);

				window->DrawList->AddLine(tang + ImVec2(-SIZE, SIZE), tang + ImVec2(SIZE, SIZE), col);
				window->DrawList->AddLine(tang + ImVec2(SIZE, SIZE), tang + ImVec2(SIZE, -SIZE), col);
				window->DrawList->AddLine(tang + ImVec2(SIZE, -SIZE), tang + ImVec2(-SIZE, -SIZE), col);
				window->DrawList->AddLine(tang + ImVec2(-SIZE, -SIZE), tang + ImVec2(-SIZE, SIZE), col);

				bool changed = false;
				if (ImGui::IsItemActive() && ImGui::IsMouseDragging(0))
				{
					tang = ImGui::GetIO().MousePos - pos;
					tang = normalized(tang);
					tang.y *= -1;

					t = tang;
					changed = true;
				}
				ImGui::PopID();

				ImGui::SetCursorScreenPos(cursor_pos);
				return changed;
			};

			ImGui::PushID(point_idx);
			if ((flags & (int)CurveEditorFlags::NO_TANGENTS) == 0)
			{
				window->DrawList->AddBezierCurve(
					transform(p_prev),
					transform(p_prev + tangent_last),
					transform(p + tangent),
					transform(p),
					ImGui::GetColorU32(ImGuiCol_PlotLines),
					1.0f,
					20);
				if (handleTangent(tangent_last, p_prev, 0))
				{
					points[1] = ImClamp(tangent_last, ImVec2(0, -1), ImVec2(1, 1));
					changed_idx = point_idx;
				}
				if (handleTangent(tangent, p, 1))
				{
					points[2] = ImClamp(tangent, ImVec2(-1, -1), ImVec2(0, 1));
					changed_idx = point_idx + 1;
				}
				if (handlePoint(p, 1))
				{
					if (p.x <= p_prev.x) p.x = p_prev.x + 0.001f;
					if (point_idx < points_count - 2 && p.x >= points[6].x)
					{
						p.x = points[6].x - 0.001f;
					}
					points[3] = p;
					changed_idx = point_idx + 1;
				}
			}
			else
			{
				window->DrawList->AddLine(transform(p_prev), transform(p), ImGui::GetColorU32(ImGuiCol_PlotLines), 1.0f);
				if (handlePoint(p, 1))
				{
					if (p.x <= p_prev.x)
						p.x = p_prev.x + 0.001f;

					if (point_idx < points_count - 2 && p.x >= points[2].x)
					{
						p.x = points[2].x - 0.001f;
					}
					points[1] = p;
					changed_idx = point_idx + 1;
				}
			}
			if (point_idx == 0)
			{
				if (handlePoint(p_prev, 0))
				{
					if (p.x <= p_prev.x)
						p_prev.x = p.x - 0.001f;

					points[0] = p_prev;
					changed_idx = point_idx;
				}
			}
			ImGui::PopID();
		}

		ImGui::SetCursorScreenPos(inner_bb.Min);
		ImGui::InvisibleButton("bg", inner_bb.Max - inner_bb.Min);

		if (ImGui::IsItemActive() && ImGui::IsMouseDoubleClicked(0) && new_count)
		{
			ImVec2 mp = ImGui::GetMousePos();
			ImVec2 new_p = invTransform(mp);
			ImVec2* points = (ImVec2*)values;

			if ((flags & (int)CurveEditorFlags::NO_TANGENTS) == 0)
			{
				points[points_count * 3 + 0] = ImVec2(-0.2f, 0);
				points[points_count * 3 + 1] = new_p;
				points[points_count * 3 + 2] = ImVec2(0.2f, 0);;
				++* new_count;

				auto compare = [](const void* a, const void* b) -> int
				{
					float fa = (((const ImVec2*)a) + 1)->x;
					float fb = (((const ImVec2*)b) + 1)->x;
					return fa < fb ? -1 : (fa > fb) ? 1 : 0;
				};

				qsort(values, points_count + 1, sizeof(ImVec2) * 3, compare);
			}
			else
			{
				points[points_count] = new_p;
				++* new_count;

				auto compare = [](const void* a, const void* b) -> int
				{
					float fa = ((const ImVec2*)a)->x;
					float fb = ((const ImVec2*)b)->x;
					return fa < fb ? -1 : (fa > fb) ? 1 : 0;
				};

				qsort(values, points_count + 1, sizeof(ImVec2), compare);
			}
		}

		if (hovered_idx >= 0 && ImGui::IsMouseDoubleClicked(0) && new_count && points_count > 2)
		{
			ImVec2* points = (ImVec2*)values;
			--* new_count;
			if ((flags & (int)CurveEditorFlags::NO_TANGENTS) == 0)
			{
				for (int j = hovered_idx * 3; j < points_count * 3 - 3; j += 3)
				{
					points[j + 0] = points[j + 3];
					points[j + 1] = points[j + 4];
					points[j + 2] = points[j + 5];
				}
			}
			else
			{
				for (int j = hovered_idx; j < points_count - 1; ++j)
				{
					points[j] = points[j + 1];
				}
			}
		}

		ImGui::EndChildFrame();
		ImGui::RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

		return changed_idx;
	}
#endif
}// namespace ImWidgets
